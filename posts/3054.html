<!DOCTYPE html><html lang="zh-CN"><head><link rel="stylesheet" href="/css/bilicard.css"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="空中有零，零域，分享快乐，音乐，心得，生活，电影，代码，编程，考试，学业，零式的天空，凌空博客，原零空博客，原Tans博客，现零的小屋官方博客，计算机，音乐，电脑，编程，生活，分享"><meta name="description" content="一个技术控，爱技术，爱分享，爱音乐"><meta name="author" content="Pin Young"><title>Objective-C Runtime 详解 | 零域</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/img/favicon.png"><link rel="stylesheet" href="/font/css/fontawesome.min.css"><link rel="stylesheet" href="/font/css/regular.min.css"><link rel="stylesheet" href="/font/css/solid.min.css"><link rel="stylesheet" href="/font/css/brands.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"0skyu.cn",root:"/",language:"zh-CN",path:"search.xml"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!0,init_open:!0},style:{primary_color:"#EE5A24",logo:"/img/favicon.png",favicon:"/img/favicon.png",avatar:"img/1.jpg",font_size:null,font_family:null,hover:{shadow:!0,scale:!1},first_screen:{enable:!0,header_transparent:!1,background_img:"/img/bg/333.jpg",description:"Keep writing and Keep loving.",font_color:"#f0d21a",hitokoto:!0},scroll:{progress_bar:!0,percent:!1}},local_search:{enable:!0,preload:!0},code_copy:{},code_block:{tools:{enable:!0,style:"default"},highlight_theme:"default"},side_tools:{},pjax:{enable:!0},lazyload:{enable:!0},comment:{enable:!1,use:"gitalk",valine:{appid:null,appkey:null,server_urls:null,placeholder:null},gitalk:{github_id:"DsTansice",github_admins:"DsTansice",repository:"Null-Comment",client_id:"b109b534b2268088d780",client_secret:"7808e138a1ffbcd9f02bb39cc1ee7fb41828c52f",proxy:null},twikoo:{env_id:"twikoo-0skyucn-1gkzaji32bb03146",region:null,version:"1.6.8"},waline:{server_url:null,reaction:!1,version:2}},post:{author_label:{enable:!0,auto:!0,custom_label_list:["Trainee","Engineer","Architect"]},word_count:{enable:!0,wordcount:!0,min2read:!0},img_align:"left",copyright_info:!0},version:"3.6.1"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"},KEEP.language_code_block={copy:"复制代码",copied:"已复制",fold:"折叠代码块",folded:"已折叠"},KEEP.language_copy_copyright={copy:"复制版权信息",copied:"已复制",title:"原文标题",author:"原文作者",link:"原文链接"}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="零域" type="application/atom+xml">
</head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/"><img src="/img/favicon.png"> </a><a class="logo-title" href="/">零域</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item"><a target="_blank" rel="noopener" href="https://hao.0skyu.cn/">HAO</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li><li class="drawer-menu-item flex-center"><a target="_blank" rel="noopener" href="https://hao.0skyu.cn/">HAO</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="post-page-container"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">Objective-C Runtime 详解</span></div><div class="article-header"><div class="avatar"><img src="/img/1.jpg"></div><div class="info"><div class="author"><span class="name">Pin Young</span> <span class="author-label">Lv9</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-calendar-plus"></i>&nbsp; <span class="pc">2021-03-28 00:00:00</span> <span class="mobile">2021-03-28 00:00</span> </span><span class="article-update-date article-meta-item"><i class="fas fa-file-pen"></i>&nbsp; <span class="pc">2023-02-05 21:25:09</span> </span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/iOS/">iOS</a>&nbsp;</li><li>| <a href="/tags/Obj-C/">Obj-C</a>&nbsp;</li><li>| <a href="/tags/Runtime/">Runtime</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>9.5k 字</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>37 分钟</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content keep-markdown-body"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>最近在学习Runtime的知识，恰巧发现了这篇博客<a class="link" target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/">《Objective-C Runtime》<i class="fas fa-external-link-alt"></i></a>，在此基础上，进行了些许补充说明,如有错误或其他想法，欢迎提出交流。</p></blockquote><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li>引言</li><li>简介</li><li>与Runtime交互</li><li>RunTime术语</li><li>消息</li><li>动态方法解析</li><li>消息转发</li><li>健壮的实例变量</li><li>动态添加属性(Object-C Associated Objects)</li><li>方法调剂（Method Swizzling）</li><li>总结</li></ul><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Objective-C的方法调用实则为“发送消息”,我们来看<code>[dog eat]</code>实际会被编译器转化为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(dog, SEL)//SEL为eat方法的标识符@selector(@&quot;eat&quot;)</span><br></pre></td></tr></table></figure><p>若方法中函数参数，则为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(dog, SEL, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><p>如果消息的接收者能够找到对应的方法，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个方法对应的实现内容，要么就干脆就crash掉。</p><p>现在可以看出<code>[dog eat]</code>真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送<code>eat</code>这条消息，而<code>dog</code>将要如何响应这条消息，那就要看运行时发生的情况来决定了。</p><p>Objective-C 的 Runtime 铸就了它动态语言的特性，这些深层次的知识虽然平时写代码用的少一些，但是却是每个 Objc 程序员需要了解的。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>因为Objc是一门动态语言，所以它总是想办法把一些决定工作从编译连接推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统 (runtime system) 来执行编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个Objc运行框架的一块基石。</p><p>Runtime其实有两个版本:“modern”和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行(Modern)版的Runtime系统，只能运行在 iOS 和 OS X 10.5 之后的64位程序中。而OS X较老的32位程序仍采用 Objective-C 1中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。</p><p>Runtime基本是用C和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在<a class="link" target="_blank" rel="noopener" href="https://opensource.apple.com/source/objc4/">这里<i class="fas fa-external-link-alt"></i></a>下到苹果维护的开源代码。苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。</p><h3 id="与Runtime交互"><a href="#与Runtime交互" class="headerlink" title="与Runtime交互"></a>与Runtime交互</h3><p>Objc 从<code>三种</code>不同的层级上与 Runtime 系统进行交互，分别是通过 <code>Objective-C 源代码</code>，通过 Foundation 框架的<code>NSObject类定义的方法</code>，通过对 <code>runtime 函数</code>的直接调用。</p><h4 id="Objective-C源代码"><a href="#Objective-C源代码" class="headerlink" title="Objective-C源代码"></a>Objective-C源代码</h4><p>大部分情况下你就只管写你的Objc代码就行，runtime 系统自动在幕后辛勤劳作着。<br>还记得引言中举的例子吧，消息的执行会使用到一些编译器为实现动态语言特性而创建的数据结构和函数，Objc中的类、方法和协议等在 runtime 中都由一些数据结构来定义，这些内容在后面会讲到。（比如<code>objc_msgSend</code>函数及其参数列表中的<code>id</code>和<code>SEL</code>都是啥）</p><h4 id="NSObject的方法"><a href="#NSObject的方法" class="headerlink" title="NSObject的方法"></a>NSObject的方法</h4><p>Cocoa 中大多数类都继承于<code>NSObject</code>类，也就自然继承了它的方法。最特殊的例外是<code>NSProxy</code>，它是个抽象超类，它实现了一些消息转发有关的方法，可以通过继承它来实现一个其他类的替身类或是虚拟出一个不存在的类，说白了就是领导把自己展现给大家风光无限，但是把活儿都交给幕后小弟去干。</p><p>有的<code>NSObject</code>中的方法起到了抽象接口的作用，比如<code>description</code>方法需要你重载它并为你定义的类提供描述内容。<code>NSObject</code>还有些方法能在运行时获得类的信息，并检查一些特性，比如<code>class</code>返回对象的类；<code>isKindOfClass</code>:和<code>isMemberOfClass:</code>则检查对象是否在指定的类继承体系中；<code>respondsToSelector:</code>检查对象能否响应指定的消息；<code>conformsToProtocol:</code>检查对象是否实现了指定协议类的方法；<code>methodForSelector:</code>则返回指定方法实现的地址。</p><h4 id="Runtime的函数"><a href="#Runtime的函数" class="headerlink" title="Runtime的函数"></a>Runtime的函数</h4><p>Runtime 系统是一个由一系列函数和数据结构组成，具有公共接口的动态共享库。头文件存放于<code>/usr/include/objc</code>目录下。许多函数允许你用纯C代码来重复实现 Objc 中同样的功能。虽然有一些方法构成了<code>NSObject</code>类的基础，但是你在写 Objc 代码时一般不会直接用到这些函数的，除非是写一些 Objc 与其他语言的桥接或是底层的debug工作。在<a class="link" target="_blank" rel="noopener" href="https://developer.apple.com/reference/objectivec/1657527-objective_c_runtime">Objective-C Runtime Reference<i class="fas fa-external-link-alt"></i></a>中有对 Runtime 函数的详细文档。</p><h3 id="Runtime术语"><a href="#Runtime术语" class="headerlink" title="Runtime术语"></a>Runtime术语</h3><p>还记得引言中的<code>objc_msgSend:</code>方法吧，它的真身是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend ( id self, SEL op, ... );</span><br></pre></td></tr></table></figure><p>下面将会逐渐展开介绍一些术语，其实它们都对应着数据结构。</p><h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p><code>objc_msgSend</code>函数第二个参数类型为<code>SEL</code>，它是<code>selector</code>在Objc中的表示类型（Swift中是<code>Selector</code>类）。<code>selector</code>是方法选择器，可以理解为区分方法的标识，而这个标识的数据结构是SEL:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure><p>本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。这个查找过程我们将在下面讨论。</p><p>我们可以在运行时添加新的selector，也可以在运行时获取已存在的selector，我们可以通过下面三种方法来获取SEL:</p><ol><li><p>sel_registerName函数</p></li><li><p>Objective-C编译器提供的@selector()</p></li><li><p>NSSelectorFromString()方法</p></li></ol><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p><code>objc_msgSend</code>第一个参数类型为<code>id</code>，大家对它都不陌生，它是一个指向类实例的指针：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure><p>那<code>objc_object</code>又是啥呢：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123; Class isa; &#125;;</span><br></pre></td></tr></table></figure><p><code>objc_object</code>结构体包含一个<code>isa</code>指针，根据<code>isa</code>指针就可以顺藤摸瓜找到对象所属的类。</p><p>PS:<code>isa</code>指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用<code>class</code>方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 <strong>isa-swizzling</strong> 的技术，详见<a class="link" target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html#//apple_ref/doc/uid/20002307-BAJEAIEE">官方文档<i class="fas fa-external-link-alt"></i></a>的这句段说明</p><blockquote><p>Key-Value Observing Implementation Details</p></blockquote><blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p></blockquote><blockquote><p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p></blockquote><blockquote><p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p></blockquote><blockquote><p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p></blockquote><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>之所以说<code>isa</code>是指针是因为<code>Class</code>其实是一个指向<code>objc_class</code>结构体的指针：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure><p>而<code>objc_class</code>就是我们摸到的那个瓜，里面的东西多着呢：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议</p><p>PS:<code>OBJC2_UNAVAILABLE</code>之类的宏定义是苹果在 Objc 中对系统运行版本进行约束的黑魔法，为的是兼容非Objective-C 2.0的遗留逻辑，但我们仍能从中获得一些有价值的信息，有兴趣的可以查看源代码</p><p><code>Objective-C 2.0</code> 的头文件虽然没暴露出<code>objc_class</code>结构体更详细的设计，我们依然可以从<code>Objective-C 1.0</code> 的定义中小窥端倪</p><p>在<code>objc_class</code>结构体中：<code>ivars</code>是<code>objc_ivar_list</code>指针；<code>methodLists</code>是指向<code>objc_method_list</code>指针的指针。也就是说可以动态修改<code>*methodLists</code>的值来添加成员方法，这也是Category实现的原理，同样解释了Category不能添加属性的原因。而最新版的 Runtime 源码对这一块的描述已经有很大变化，可以参考下美团技术团队的<a class="link" target="_blank" rel="noopener" href="http://tech.meituan.com/DiveIntoCategory.html">深入理解Objective-C：Category<i class="fas fa-external-link-alt"></i></a>.</p><p>PS：任性的话可以在Category中添加<code>@dynamic</code>的属性，并利用运行期动态提供存取方法或干脆动态转发；或者干脆使用关联度对象（AssociatedObject）</p><p>其中<code>objc_ivar_list</code>和<code>objc_method_list</code>分别是成员变量列表和方法列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct objc_ivar_list &#123;</span><br><span class="line">    int ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">    /* variable length structure */</span><br><span class="line">    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">struct objc_method_list &#123;</span><br><span class="line">    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    int method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">    /* variable length structure */</span><br><span class="line">    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你C语言不是特别好，可以理解为<code>objc_ivar_list</code>结构体存储着<code>objc_ivar</code>数组列表，而<code>objc_ivar</code>结构体存储了类的单个成员变量的信息；同理<code>objc_method_list</code>结构体存储着<code>objc_method</code>数组列表，而o<code>bjc_method</code>结构体存储了类的某个方法的信息。</p><p>最后要提到的还有一个<code>objc_cache</code>，顾名思义它是缓存，它在<code>objc_class</code>的作用很重要，在后面会讲到。</p><p>不知道你是否注意到了<code>objc_class</code>中也有一个<code>isa</code>对象，这是因为一个 ObjC 类本身同时也是一个对象，为了处理类和对象的关系，runtime 库创建了一种叫做元类 (Meta Class) 的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。当你发出一个类似<code>[NSObject alloc]</code>的消息时，你事实上是把这个消息发给了一个类对象 (Class Object) ，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class) 的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 <code>[NSObject alloc]</code> 这条消息发给类对象的时候，<code>objc_msgSend()</code>会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。</p><p><img lazyload alt="image" data-src="http://7ni3rk.com1.z0.glb.clouddn.com/Runtime/class-diagram.jpg"></p><p>上图实线是 <code>super_class</code> 指针，虚线是<code>isa</code>指针。 有趣的是根元类的超类是<code>NSObjec</code>t，而<code>isa</code>指向了自己，而<code>NSObject</code>的超类为<code>nil</code>，也就是它没有超类</p><p>####Method</p><p><code>Method</code>是一种代表类中的某个方法的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method;</span><br></pre></td></tr></table></figure><p>而<code>objc_method</code>在上面的方法列表中提到过，它存储了方法名，方法类型和方法实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>方法名 <code>method_name</code> 类型为 <code>SEL</code>, 相同名字的方法即使在不同类中定义，它们的方法选择器也相同。</li><li>方法类型<code>method_types</code>是个<code>char</code>指针，存储着方法的 参数类型 和 返回值 类型。</li><li><code>method_imp</code>指向了方法的实现，本质上是一个函数指针，后面会详细讲到。</li></ul><h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h4><p>Ivar是一种代表类中实例变量的类型。定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_ivar *Ivar;</span><br></pre></td></tr></table></figure><p>它是一个指向objc_ivar结构体的指针，结构体有如下定义:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct objc_ivar &#123;</span><br><span class="line">    char *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    int ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>这里我们注意第三个成员 <code>ivar_offset</code>。它表示基地址偏移字节。</p><p>在编译我们的类时，编译器生成了一个 <code>ivar</code> 布局，显示了在类中从哪可以访问我们的 <code>ivars</code> 。</p><p>我们对 ivar 的访问就可以通过 <code>对象地址</code> ＋ <code>ivar偏移字节</code>的方法。</p><p>但是当我们增加了父类的<code>ivar</code>，这个时候布局就出错了，我们就不得不重新编译子类来恢复兼容性。</p><p>而Objective－C Runtime中使用了<code>Non Fragile ivars</code>来避免这个问题</p><p>使用<code>Non Fragile ivars</code>时，Runtime会进行检测来调整类中新增的<code>ivar</code>的偏移量。 这样我们就可以通过 <code>对象地址 ＋ 基类大小 + ivar偏移字节</code>的方法来计算出<code>ivar</code>相应的地址，并访问到相应的<code>ivar</code>。</p><p>可以根据实例查找其在类中的名字，也就是“反射”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-(NSString *)nameWithInstance:(id)instance &#123;</span><br><span class="line">    unsigned int numIvars = 0;</span><br><span class="line">    NSString *key=nil;</span><br><span class="line">    Ivar * ivars = class_copyIvarList([self class], &amp;numIvars);</span><br><span class="line">    for(int i = 0; i &lt; numIvars; i++) &#123;</span><br><span class="line">        Ivar thisIvar = ivars[i];</span><br><span class="line">        const char *type = ivar_getTypeEncoding(thisIvar);</span><br><span class="line">        NSString *stringType =  [NSString stringWithCString:type encoding:NSUTF8StringEncoding];</span><br><span class="line">        if (![stringType hasPrefix:@&quot;@&quot;]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((object_getIvar(self, thisIvar) == instance)) &#123;//此处若 crash 不要慌！</span><br><span class="line">            key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivars);</span><br><span class="line">    return key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>class_copyIvarList</code> 函数获取的不仅有实例变量，还有属性。但会在原本的属性名前加上一个下划线。(属性的本质就是 <code>_属性名+set+get方法</code>)</p><h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p><code>IMP</code>在<code>objc.h</code>中的定义是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef id (*IMP)(id, SEL, ...);</span><br></pre></td></tr></table></figure><p>它就是一个<a class="link" target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2014/04/17/han-shu-zhi-zhen-yu-zhi-zhen-han-shu/">函数指针<i class="fas fa-external-link-alt"></i></a>，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 <code>IMP</code> 这个函数指针就指向了这个方法的实现。既然得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面会提到。</p><p>我们再来看看objc_msgSend()的定义：<code>id objc_msgSend(id self, SEL op, ...)</code></p><p>你会发现<code>IMP</code>指向的方法与<code>objc_msgSend</code>函数类型相同，参数都包含id和SEL类型。每个方法名都对应一个SEL类型的方法选择器，而每个实例对象中的<code>SEL</code>对应的方法实现肯定是唯一的，通过一组<code>id</code>和<code>SEL</code>参数就能确定唯一的方法实现地址。</p><h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>在<code>runtime.h</code>中Cache的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_cache *Cache</span><br></pre></td></tr></table></figure><p>还记得之前 <code>objc_class</code> 结构体中有一个 <code>struct objc_cache *cache</code> 吧，它到底是缓存啥的呢，先看看 <code>objc_cache</code> 的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct objc_cache &#123;</span><br><span class="line">    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;</span><br><span class="line">    unsigned int occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method buckets[1]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>objc_cache</code> 的定义看起来很简单，它包含了下面三个变量：</p><ul><li><code>mask</code>:可以认为是当前能达到的最大index（从0开始的），所以缓存的size（total）是mask+1</li><li><code>occupied</code>:被占用的槽位，因为缓存是以散列表的形式存在的，所以会有空槽，而occupied表示当前被占用的数目</li><li><code>buckets</code>:用数组表示的hash表，cache_entry类型，每一个cache_entry代表一个方法缓存</li></ul><p>(buckets定义在objc_cache的最后，说明这是一个可变长度的数组)</p><p><code>Cache</code>为方法调用的性能进行优化,下面我们来看看<code>objc_msgSend</code>具体又是如何分发的呢？ 我们来看下runtime层<code>objc_msgSend</code>的源码。</p><p>在<code>objc-msg-arm.s</code>中，<code>objc_msgSend</code>的代码如下：</p><p>ps：Apple为了高度优化objc_msgSend的性能，这个文件是汇编写成的，不过即使我们不懂汇编，详尽的注释也可以让我们一窥其真面目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ENTRY objc_msgSend</span><br><span class="line"># check whether receiver is nil</span><br><span class="line">teq     a1, #0</span><br><span class="line">    beq     LMsgSendNilReceiver</span><br><span class="line"># save registers and load receiver&#x27;s class for CacheLookup</span><br><span class="line">stmfd   sp!, &#123;a4,v1&#125;</span><br><span class="line">ldr     v1, [a1, #ISA]</span><br><span class="line"># receiver is non-nil: search the cache</span><br><span class="line">CacheLookup a2, v1, LMsgSendCacheMiss</span><br><span class="line"># cache hit (imp in ip) and CacheLookup returns with nonstret (eq) set, restore registers and call</span><br><span class="line">ldmfd   sp!, &#123;a4,v1&#125;</span><br><span class="line">bx      ip</span><br><span class="line"># cache miss: go search the method lists</span><br><span class="line">LMsgSendCacheMiss:</span><br><span class="line">ldmfd sp!, &#123;a4,v1&#125;</span><br><span class="line">b _objc_msgSend_uncached</span><br><span class="line">LMsgSendNilReceiver:</span><br><span class="line">    mov     a2, #0</span><br><span class="line">    bx      lr</span><br><span class="line">LMsgSendExit:</span><br><span class="line">END_ENTRY objc_msgSend</span><br><span class="line">STATIC_ENTRY objc_msgSend_uncached</span><br><span class="line"># Push stack frame</span><br><span class="line">stmfd sp!, &#123;a1-a4,r7,lr&#125;</span><br><span class="line">add     r7, sp, #16</span><br><span class="line"># Load class and selector</span><br><span class="line">ldr a3, [a1, #ISA] /* class = receiver-&gt;isa  */</span><br><span class="line">/* selector already in a2 */</span><br><span class="line">/* receiver already in a1 */</span><br><span class="line"># Do the lookup</span><br><span class="line">MI_CALL_EXTERNAL(__class_lookupMethodAndLoadCache3)</span><br><span class="line">MOVE    ip, a1</span><br><span class="line"># Prep for forwarding, Pop stack frame and call imp</span><br><span class="line">teq v1, v1 /* set nonstret (eq) */</span><br><span class="line">ldmfd sp!, &#123;a1-a4,r7,lr&#125;</span><br><span class="line">bx ip</span><br></pre></td></tr></table></figure><p>如果向更深入了解 <code>objc_cache</code> ,可以看看这篇博文<a class="link" target="_blank" rel="noopener" href="http://www.cocoachina.com/ios/20150818/13075.html">深入理解Objective-C：方法缓存<i class="fas fa-external-link-alt"></i></a></p><p>从上述代码中可以看到，<code>objc_msgSend</code>（就ARM平台而言）的消息分发分为以下几个步骤：</p><ol><li>判断receiver是否为nil，也就是objc_msgSend的第一个参数self，也就是要调用的那个方法所属对象</li><li>从缓存里寻找，找到了则分发，否则</li><li>利用objc-class.mm中_class_lookupMethodAndLoadCache3（为什么有个这么奇怪的方法。本文末尾会解释）方法去寻找selector</li><li>如果支持GC，忽略掉非GC环境的方法（retain等）</li><li>从本class的method list寻找selector，如果找到，填充到缓存中，并返回selector，否则</li><li>寻找父类的method list，并依次往上寻找，直到找到selector，填充到缓存中，并返回selector，否则</li><li>调用_class_resolveMethod，如果可以动态resolve为一个selector，不缓存，方法返回，否则</li><li>转发这个selector，否则</li><li>报错，抛出异常</li></ol><p>从上面的分析中我们可以看到，当一个方法在比较“上层”的类中，用比较“下层”（继承关系上的上下层）对象去调用的时候，如果没有缓存，那么整个查找链是相当长的。就算方法是在这个类里面，当方法比较多的时候，每次都查找也是费事费力的一件事情。</p><p>当我们需要去调用一个方法数十万次甚至更多地时候，查找方法的消耗会变的非常显著。就算我们平常的非大规模调用，<code>除非一个方法只会调用一次，否则缓存都是有用的。</code>在运行时，那么多对象，那么多方法调用，节省下来的时间也是非常可观的。可见缓存的重要性。</p><p>方法缓存存在什么地方？</p><p>让我们再去去翻看 <code>objc_class</code> 的定义，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>我们看到在类的定义里就有<code>cache</code>字段，没错，类的所有缓存都存在metaclass上，所以每个类都只有一份方法缓存，而不是每一个类的object都保存一份。</p><p>子类类即便是从父类取到的方法，也会存在类本身的方法缓存里。而当用一个父类对象去调用那个方法的时候，也会在父类的metaclass里缓存一份。</p><h4 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h4><p><code>@property</code>标记了类中的属性，这个不必多说大家都很熟悉，它是一个指向objc_property结构体的指针：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_property *Property;</span><br><span class="line">typedef struct objc_property *objc_property_t;//这个更常用</span><br></pre></td></tr></table></figure><p>现在在类中声明声明属性和成员变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">&#123;</span><br><span class="line">    int age;</span><br><span class="line">    NSString *name;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, strong) NSString *property1;</span><br><span class="line">@property (nonatomic, strong) NSString *property2;</span><br><span class="line">@property (nonatomic, assign) int age;//这里的age为属性，对应变量：_age</span><br><span class="line">@property (nonatomic, assign) long ID;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>然后用下面的方法来获取类中属性列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">id LenderClass = objc_getClass(&quot;ViewController&quot;);//获取calss</span><br><span class="line">//id LenderClass = [MyViewController class];//同上</span><br><span class="line">unsigned int outCount;//属性数量</span><br><span class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);//获取属性列表</span><br><span class="line">for (int i = 0; i &lt; outCount; i++) &#123;// 遍历</span><br><span class="line">    objc_property_t property = properties[i];</span><br><span class="line">    const char *propertyName = property_getName(property);</span><br><span class="line">    const char *propertyAttributes = property_getAttributes(property);</span><br><span class="line">    printf(&quot;propertyName：%s \n&quot;, propertyName);</span><br><span class="line">    printf(&quot;propertyAttributes:%s\n--------\n&quot;, propertyAttributes);//属性名及描述</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">propertyName：property1 </span><br><span class="line">propertyAttributes:T@&quot;NSString&quot;,&amp;,N,V_property1</span><br><span class="line">--------</span><br><span class="line">propertyName：property2 </span><br><span class="line">propertyAttributes:T@&quot;NSString&quot;,&amp;,N,V_property2</span><br><span class="line">--------</span><br><span class="line">propertyName：age </span><br><span class="line">propertyAttributes:Ti,N,V_age</span><br><span class="line">--------</span><br><span class="line">propertyName：ID </span><br><span class="line">propertyAttributes:Tq,N,V_ID</span><br></pre></td></tr></table></figure><p>我们再来来看看获取成员变量的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">id selfClass = [self class];</span><br><span class="line">unsigned int numIvars = 0;</span><br><span class="line">Ivar *ivars = class_copyIvarList(selfClass, &amp;numIvars);</span><br><span class="line">for(int i = 0; i &lt; numIvars; i++) &#123;</span><br><span class="line">    Ivar ivar = ivars[i];</span><br><span class="line">    const char *ivarType = ivar_getTypeEncoding(ivar);// 获取类型</span><br><span class="line">    const char *ivarName = ivar_getName(ivar);</span><br><span class="line">    printf(&quot;ivarName:%s\n&quot;, ivarName);</span><br><span class="line">    printf(&quot;ivarType:%s\n------\n&quot;, ivarType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ivarName:age</span><br><span class="line">ivarType:i</span><br><span class="line">------</span><br><span class="line">ivarName:name</span><br><span class="line">ivarType:@&quot;NSString&quot;</span><br><span class="line">------</span><br><span class="line">ivarName:_age</span><br><span class="line">ivarType:i</span><br><span class="line">------</span><br><span class="line">ivarName:_property1</span><br><span class="line">ivarType:@&quot;NSString&quot;</span><br><span class="line">------</span><br><span class="line">ivarName:_property2</span><br><span class="line">ivarType:@&quot;NSString&quot;</span><br><span class="line">------</span><br><span class="line">ivarName:_ID</span><br><span class="line">ivarType:q</span><br></pre></td></tr></table></figure><p>我们会发现与 <code>class_copyIvarList</code> 函数不同，使用 <code>class_copyPropertyList</code> 函数只能获取类的属性，而不包含成员变量。但此时获取的属性名是不带下划线的,得到属性或者变量名后我们就可以使用KVC去修改访问类中的私有属性或变量。所以OC中没有真正意义上的私有变量，私有方法也是。</p><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>前面做了这么多铺垫，现在终于说到了消息了。Objc 中发送消息是用中括号 <code>[]</code> 把接收者和消息括起来，而直到运行时才会把消息与方法实现绑定。</p><p>有关消息发送和消息转发机制的原理，可以查看<a class="link" target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/">这篇文章<i class="fas fa-external-link-alt"></i></a>。</p><h4 id="objc-msgSend函数"><a href="#objc-msgSend函数" class="headerlink" title="objc_msgSend函数"></a>objc_msgSend函数</h4><p>在引言中已经对 <code>objc_msgSend</code> 进行了一点介绍，看起来像是 <code>objc_msgSend</code> 返回了数据，其实 <code>objc_msgSend</code> 从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：</p><ol><li>检测这个 消息 是不是要忽略的。比如 Mac OS X 开发，在ARC中有了垃圾回收就不理会MRC的 <code>retain</code>, <code>release</code> 这些函数了。</li><li>检测这个 目标对象 是不是 <code>nil</code> 对象。ObjC 的特性是允许对一个 <code>nil</code> 对象执行任何一个方法不会 Crash，因为会被忽略掉。</li><li>如果上面两个都过了，那就开始查找这个类的 <code>IMP</code>，先从 <code>cache</code> 里面找，完了找得到就跳到对应的函数去执行。</li><li>如果 <code>cache</code> 找不到就找一下方法分发表。</li><li>如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。</li><li>如果还找不到就要开始进入动态方法解析了，后面会提到。</li></ol><p>PS:这里说的分发表其实就是 <code>Class</code> 中的方法列表，它将方法选择器和方法实现地址联系起来。<br><img lazyload alt="image" data-src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif"></p><p>其实编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code>四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有”Super”的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有<code>”stret”</code>的函数。排列组合正好四个方法</p><p>PS：有木有发现这些函数的命名规律哦？带 <code>“Super”</code> 的是消息传递给超类；<code>“stret”</code>可分为<code>“st”</code>+<code>“ret”</code>两部分，分别代表 <code>“struct”</code> 和 <code>“return”</code> ；<code>“fpret”</code>就是 <code>“fp”</code> + <code>“ret”</code>，分别代表<code>“floating-point”</code>和 <code>“return”</code>。</p><h4 id="方法中的隐藏参数"><a href="#方法中的隐藏参数" class="headerlink" title="方法中的隐藏参数"></a>方法中的隐藏参数</h4><p>我们经常在方法中使用 <code>self</code> 关键字来引用实例本身，但从没有想过为什么 <code>self</code> 就能取到调用当前方法的对象吧。其实 <code>self</code> 的内容是在方法运行时被偷偷的动态传入的</p><p>当 <code>objc_msgSend</code> 找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现,同时,它还将传递两个隐藏的参数:</p><ul><li>接收消息的对象（也就是<code>self</code>指向的内容）</li><li>方法选择器（<code>_cmd</code>指向的内容）</li></ul><p>之所以说它们是隐藏的是因为在源代码方法的定义中并没有声明这两个参数。它们是在代码被编译时被插入实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。在下面的例子中，<code>self</code>引用了接收者对象，而<code>_cmd</code>引用了方法本身的选择器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- strange</span><br><span class="line">&#123;</span><br><span class="line">    id  target = getTheReceiver();</span><br><span class="line">    SEL method = getTheMethod();</span><br><span class="line"> </span><br><span class="line">    if ( target == self || method == _cmd )</span><br><span class="line">        return nil;</span><br><span class="line">    return [target performSelector:method];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这两个参数中，<code>self</code> 更有用。实际上,它是在方法实现中访问消息接收者对象的实例变量的途径</p><p>而当方法中的 <code>super</code> 关键字接收到消息时，编译器会创建一个 <code>objc_super</code> 结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct objc_super &#123; id receiver; Class class; &#125;;</span><br></pre></td></tr></table></figure><p>这个结构体指明了消息应该被传递给特定父类的定义。但<code>receiver</code>仍然是<code>self</code>本身，这点需要注意，因为当我们想通过<code>[super class]</code>获取超类时，编译器只是将指向<code>self</code>的<code>id</code>指针和<code>class</code>的<code>SEL</code>传递给了o<code>bjc_msgSendSuper</code>函数，因为只有在<code>NSObject</code>类才能找到<code>class</code>方法，然后<code>class</code>方法调用<code>object_getClass()</code>，接着调用<code>objc_msgSend(objc_super-&gt;receiver</code>, <code>@selector(class))</code>，传入的第一个参数是指向<code>self</code>的<code>id</code>指针，与调用<code>[self class]</code>相同，所以我们得到的永远都是<code>self</code>的类型。</p><h4 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h4><p>在 <code>IMP</code> 那节提到过可以避开消息绑定而直接获取方法的地址并调用方法。这种做法很少用，除非是需要持续大量重复调用某方法的极端情况，避开消息发送泛滥而直接调用该方法会更高效。<br>NSObject类中有个<code>methodForSelector:</code>实例方法，你可以用它来获取某个方法选择器对应的 <code>IMP</code> ，举个栗子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void (*imp)(id, SEL, BOOL);//定义一个函数指针</span><br><span class="line">imp = (void (*)(id, SEL, BOOL))[self methodForSelector:@selector(setFilled:)];//获取setFilled:函数的IMP</span><br></pre></td></tr></table></figure><h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>你可以动态地提供一个方法的实现。例如我们可以用 <code>@dynamic</code> 关键字在类的实现文件中修饰一个属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@dynamic propertyName;</span><br></pre></td></tr></table></figure><p>这表明我们会为这个属性提供存取方法，也就是说编译器不会默认为我们生成 <code>setPropertyName:</code>和 <code>prepertyName</code> 方法，而需要我们自己提供动态方法。我们可以通过分别重载 <code>resolveIntanceMethod：</code> 和 <code>resolvrClassMethod:</code> 方法分别添加实例方法实现和类方法实现。因为当 Runtime 系统在 <code>Cache</code> 和方法分发表中（包括父类）找不到要执行的方法时，Runtime会调用 <code>resolveIntanceMethod：</code> 和 <code>resolvrClassMethod:</code> 来给我们一次动态添加实现的机会。我们需要 <code>class_addMethod</code>函数完成向特定类添加特定方法实现的操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    // implementation ....</span><br><span class="line">&#125;</span><br><span class="line">@implementation MyClass</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">    if (aSEL == @selector(resolveThisMethodDynamically)) &#123;</span><br><span class="line">          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class="line">          return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的例子为resolveThisMethodDynamically方法添加了实现内容，也就是dynamicMethodIMP方法中的代码。其中 “v@:” 表示返回值和参数，这个符号涉及 <a class="link" target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encoding<i class="fas fa-external-link-alt"></i></a></p><p>PS：动态方法解析会在消息转发机制浸入前执行。如果 <code>respondsToSelector:</code> 或 <code>instancesRespondToSelector:</code> 方法被执行，动态方法解析器将会被首先给予一个提供该方法选择器对应的 <code>IMP</code> 的机会。如果你想让该方法选择器被传送到转发机制，那么就让<code>resolveInstanceMethod:</code> 返回 <code>NO</code> 。</p><h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>在消息转发机制执行前，Runtime 系统会再给我们一次偷梁换柱的机会，即通过重载<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code> 方法替换消息的接受者为其他对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    if(aSelector == @selector(mysteriousMethod:))&#123;</span><br><span class="line">        return alternateObject;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毕竟消息转发要耗费更多时间，抓住这次机会将消息重定向给别人是个不错的选择，不过千万别返回<code>self</code>，因为那样会死循环</p><h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><p>当动态方法解析不作处理返回NO时，消息转发机制会被触发。在这时<code>forwardInvocation:</code>方法会被执行，我们可以重写这个方法来定义我们的转发逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    if ([someOtherObject respondsToSelector:</span><br><span class="line">            [anInvocation selector]])</span><br><span class="line">        [anInvocation invokeWithTarget:someOtherObject];</span><br><span class="line">    else</span><br><span class="line">        [super forwardInvocation:anInvocation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该消息的唯一参数是个<code>NSInvocation</code>类型的对象——该对象封装了原始的消息和消息的参数。我们可以实现<code>forwardInvocation:</code>方法来对不能处理的消息做一些默认的处理，也可以将消息转发给其他对象来处理，而不抛出错误。</p><p>当一个对象由于没有相应的方法实现而无法响应某消息时，运行时系统将通过 <code>forwardInvocation:</code> 消息通知该对象。每个对象都从NSObject类中继承了 <code>forwardInvocation:</code> 方法。然而，NSObject中的方法实现只是简单地调用了 <code>doesNotRecognizeSelector:</code> 。通过实现我们自己的 <code>forwardInvocation:</code> 方法，我们可以在该方法实现中将消息转发给其它对象。</p><p><code>forwardInvocation:</code> 方法就像一个不能识别的消息的分发中心，将这些消息转发给不同接收对象。或者它也可以象一个运输站将所有的消息都发送给同一个接收对象。它可以将一个消息翻译成另外一个消息，或者简单的”吃掉“某些消息，因此没有响应也没有错误。<code>forwardInvocation:</code>方法也可以对不同的消息提供同样的响应，这一切都取决于方法的具体实现。该方法所提供是将不同的对象链接到消息链的能力。</p><p>注意： <code>forwardInvocation:</code> 方法只有在消息接收对象中无法正常响应消息时才会被调用。 所以，如果我们希望一个对象将negotiate消息转发给其它对象，则这个对象不能有<code>negotiate</code>方法。否则，<code>forwardInvocation:</code>将不可能会被调用。</p><h4 id="转发和多继承"><a href="#转发和多继承" class="headerlink" title="转发和多继承"></a>转发和多继承</h4><p>转发和继承相似，可以用于为Objc编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好似它把另一个对象中的方法借过来或是“继承”过来一样。</p><p><img lazyload alt="image" data-src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/forwarding.gif"></p><p>这使得不同继承体系分支下的两个类可以“继承”对方的方法，在上图中 <code>Warrior</code> 和 <code>Diplomat</code> 没有继承关系，但是 <code>Warrior</code> 将<code>negotiate</code> 消息转发给了 <code>Diplomat</code> 后，就好似 <code>Diplomat</code> 是 <code>Warrior</code> 的超类一样。<br>消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。它将问题分解得很细，只针对想要借鉴的方法才转发，而且转发机制是透明的</p><h4 id="替代者对象-Surrogate-Objects"><a href="#替代者对象-Surrogate-Objects" class="headerlink" title="替代者对象(Surrogate Objects)"></a>替代者对象(Surrogate Objects)</h4><p>转发不仅能模拟多继承，也能使轻量级对象代表重量级对象。弱小的女人背后是强大的男人，毕竟女人遇到难题都把它们转发给男人来做了。这里有一些适用案例，可以参看<a class="link" target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW11">官方文档<i class="fas fa-external-link-alt"></i></a>。</p><h4 id="转发于继承"><a href="#转发于继承" class="headerlink" title="转发于继承"></a>转发于继承</h4><p>尽管转发很像继承，但是NSObject类不会将两者混淆。像 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code> 这类方法只会考虑继承体系，不会考虑转发链。比如上图中一个 <code>Warrior</code> 对象如果被问到是否能响应 <code>negotiate</code> 消息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ( [aWarrior respondsToSelector:@selector(negotiate)] )</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>结果是 <code>NO</code> ，尽管它能够接受 <code>negotiate</code> 消息而不报错，因为它靠转发消息给 <code>Diplomat</code> 类来响应消息。</p><p>如果你为了某些意图偏要“弄虚作假”让别人以为<code>Warrior</code> 继承到了 <code>Diplomat</code> 的 <code>negotiate</code> 方法，你得重新实现 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code> 来加入你的转发算法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    if ( [super respondsToSelector:aSelector] )</span><br><span class="line">        return YES;</span><br><span class="line">    else &#123;</span><br><span class="line">        /* Here, test whether the aSelector message can     *</span><br><span class="line">         * be forwarded to another object and whether that  *</span><br><span class="line">         * object can respond to it. Return YES if it can.  */</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了<code>respondsToSelector:</code>和 <code>isKindOfClass:</code>之外，<code>instancesRespondToSelector:</code>中也应该写一份转发算法。如果使用了协议，<code>conformsToProtocol:</code>同样也要加入到这一行列中。类似地，如果一个对象转发它接受的任何远程消息，它得给出一个<code>methodSignatureForSelector:</code>来返回准确的方法描述，这个方法会最终响应被转发的消息。比如一个对象能给它的替代者对象转发消息，它需要像下面这样实现<code>methodSignatureForSelector:</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    NSMethodSignature* signature = [super methodSignatureForSelector:selector];</span><br><span class="line">    if (!signature) &#123;</span><br><span class="line">       signature = [surrogate methodSignatureForSelector:selector];</span><br><span class="line">    &#125;</span><br><span class="line">    return signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="健壮的实例变量-Non-Fragile-ivars"><a href="#健壮的实例变量-Non-Fragile-ivars" class="headerlink" title="健壮的实例变量(Non Fragile ivars)"></a>健壮的实例变量(Non Fragile ivars)</h3><p>在 Runtime 的现行版本中，最大的特点就是健壮的实例变量。当一个类被编译时，实例变量的布局也就形成了，它表明访问类的实例变量的位置。从对象头部地址开始，实例变量依次根据自己所占空间而产生位移：</p><p>再翻出Ivar的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct objc_ivar &#123;</span><br><span class="line">    char *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    int ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p><code>ivar</code> 的访问可以通过 <code>对象地址</code> ＋ <code>ivar偏移字节(ivar_offset)</code>的方法。</p><p>当我们增加了父类的<code>ivar</code>，这个时候布局就出错了，我们就不得不重新编译子类来恢复兼容性。</p><p>在健壮的实例变量下编译器生成的实例变量布局跟以前一样，但是当 runtime 系统检测到与超类有部分重叠时它会调整你新添加的实例变量的位移，那样你在子类中新添加的成员就被保护起来了</p><p>需要注意的是在健壮的实例变量下，不要使用 <code>sizeof(SomeClass)</code>，而是用 <code>class_getInstanceSize([SomeClass class])</code> 代替；也不要使用 <code>offsetof(SomeClass, SomeIvar)</code> ，而要用 <code>ivar_getOffset(class_getInstanceVariable([SomeClass class], &quot;SomeIvar&quot;))</code> 来代替。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/* 定义一个Student类 */</span><br><span class="line">@interface Student : NSObject</span><br><span class="line">&#123;</span><br><span class="line">@private</span><br><span class="line">    int age;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Student</span><br><span class="line">// 重写%@输出方法</span><br><span class="line">- (NSString *)description</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;current pointer = %p&quot;, self);</span><br><span class="line">    NSLog(@&quot;age pointer = %p&quot;, &amp;age);</span><br><span class="line">    return [NSString stringWithFormat:@&quot;age = %d&quot;, age];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // insert code here...</span><br><span class="line">        </span><br><span class="line">        Student *student = [[Student alloc] init];</span><br><span class="line">        Ivar age_ivar = class_getInstanceVariable(object_getClass(student), &quot;age&quot;);//获取&quot;age&quot;的ivar</span><br><span class="line">        int *age_pointer = (int *)((__bridge void *)(student) + ivar_getOffset(age_ivar));//定义一个指向age_ivar的指针：指向地址为 student对象地址 + age_ivar的偏移量（ivar_offset）</span><br><span class="line">        NSLog(@&quot;age ivar offset = %td&quot;, ivar_getOffset(age_ivar));//输出offset偏移量</span><br><span class="line">        *age_pointer = 10;//对指针age_pointer指向的变量（age_ivar）赋值</span><br><span class="line">        NSLog(@&quot;%@&quot;, student);//输出重写的description方法</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察控制台输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2016-11-11 16:22:56.364 Iavr_offset[1501:928608] age ivar offset = 8</span><br><span class="line">2016-11-11 16:22:56.365 Iavr_offset[1501:928608] current pointer = 0x100400170</span><br><span class="line">2016-11-11 16:22:56.365 Iavr_offset[1501:928608] age pointer = 0x100400178</span><br><span class="line">2016-11-11 16:22:56.366 Iavr_offset[1501:928608] age = 10</span><br></pre></td></tr></table></figure><p>我们发现<code>age pointer = current pointer + age ivar offset</code></p><h3 id="Objective-C-Associated-Objects"><a href="#Objective-C-Associated-Objects" class="headerlink" title="Objective-C Associated Objects"></a>Objective-C Associated Objects</h3><p>在 OS X 10.6 之后，Runtime系统让Objc支持向对象动态添加变量。涉及到的函数有以下三个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );</span><br><span class="line">id objc_getAssociatedObject ( id object, const void *key );</span><br><span class="line">void objc_removeAssociatedObjects ( id object );</span><br></pre></td></tr></table></figure><p>这些方法以键值对的形式动态地向对象添加、获取或删除关联值。其中关联政策是一组枚举常量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">   OBJC_ASSOCIATION_ASSIGN  = 0,</span><br><span class="line">   OBJC_ASSOCIATION_RETAIN_NONATOMIC  = 1,</span><br><span class="line">   OBJC_ASSOCIATION_COPY_NONATOMIC  = 3,</span><br><span class="line">   OBJC_ASSOCIATION_RETAIN  = 01401,</span><br><span class="line">   OBJC_ASSOCIATION_COPY  = 01403</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些常量对应着引用关联值的政策，也就是 Objc 内存管理的引用计数机制。</p><h3 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><p>之前所说的消息转发虽然功能强大，但需要我们了解并且能更改对应类的源代码，因为我们需要实现自己的转发逻辑。当我们无法触碰到某个类的源代码，却想更改这个类某个方法的实现时，该怎么办呢？可能继承类并重写方法是一种想法，但是有时无法达到目的。这里介绍的是 Method Swizzling ，它通过重新映射方法对应的实现来达到“偷天换日”的目的。跟消息转发相比，Method Swizzling 的做法更为隐蔽，甚至有些冒险，也增大了debug的难度。</p><p>这里摘抄一个 NSHipster 的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt; </span><br><span class="line"></span><br><span class="line">@implementation UIViewController (Tracking)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class class = [self class];</span><br><span class="line">        // When swizzling a class method, use the following: </span><br><span class="line">        // Class class = object_getClass((id)self); </span><br><span class="line">        SEL originalSelector = @selector(viewWillAppear:);</span><br><span class="line">        SEL swizzledSelector = @selector(xxx_viewWillAppear:);</span><br><span class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line">        BOOL didAddMethod =</span><br><span class="line">            class_addMethod(class,</span><br><span class="line">                originalSelector,</span><br><span class="line">                method_getImplementation(swizzledMethod),</span><br><span class="line">                method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        if (didAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(class,</span><br><span class="line">                swizzledSelector,</span><br><span class="line">                method_getImplementation(originalMethod),</span><br><span class="line">                method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark - Method Swizzling </span><br><span class="line">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [self xxx_viewWillAppear:animated];</span><br><span class="line">    NSLog(@&quot;viewWillAppear: %@&quot;, self);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>上面的代码通过添加一个 <code>Tracking</code> 类别到 <code>UIViewController</code> 类中，将 <code>UIViewController</code> 类的 <code>viewWillAppear:</code> 方法和 <code>Tracking</code> 类别中 <code>xxx_viewWillAppear:</code> 方法的实现相互调换。<code>Swizzling</code> 应该在 <code>+load</code> 方法中实现，因为 <code>+load</code> 是在一个类最开始加载时调用。<code>dispatch_once</code> 是GCD中的一次性方法，它保证了代码块只执行一次，并让其为一个原子操作，线程安全是很重要的。</p><p>先用 <code>class_addMethod</code> 和 <code>class_replaceMethod</code> 函数将两个方法的实现进行调换，如果类中已经有了 <code>viewWillAppear:</code> 方法的实现，那么就调用 <code>method_exchangeImplementations</code> 函数交换了两个方法的 <code>IMP</code> ，这是苹果提供给我们用于实现 <code>Method Swizzling</code> 的便捷方法。<br>最后 <code>xxx_viewWillAppear:</code> 方法的定义看似是递归调用引发死循环，其实不会的。因为 <code>[self xxx_viewWillAppear:animated]</code> 消息会动态找到 <code>xxx_viewWillAppear:</code> 方法的实现，而它的实现已经被我们与 <code>viewWillAppear:</code>方法实现进行了互换，所以这段代码不仅不会死循环，如果你把 <code>[self xxx_viewWillAppear:animated]</code> 换成 <code>[self viewWillAppear:animated]</code> 反而会引发死循环。<br>看到有人说 <code>+load</code>方法本身就是线程安全的，因为它在程序刚开始就被调用，很少会碰到并发问题，于是 <code>stackoverflow</code> 上也有大神给出了另一个 <code>Method Swizzling</code> 的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)replacementReceiveMessage:(const struct BInstantMessage *)arg1 &#123;</span><br><span class="line">    NSLog(@&quot;arg1 is %@&quot;, arg1);</span><br><span class="line">    [self replacementReceiveMessage:arg1];</span><br><span class="line">&#125;</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    SEL originalSelector = @selector(ReceiveMessage:);</span><br><span class="line">    SEL overrideSelector = @selector(replacementReceiveMessage:);</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(self, originalSelector);</span><br><span class="line">    Method overrideMethod = class_getInstanceMethod(self, overrideSelector);</span><br><span class="line">    if (class_addMethod(self, originalSelector, method_getImplementation(overrideMethod), method_getTypeEncoding(overrideMethod))) &#123;</span><br><span class="line">            class_replaceMethod(self, overrideSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, overrideMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也就是去掉了<code>dispatch_once</code>的部分罢了。</p><p><code>Method Swizzling</code> 的确是一个值得深入研究的话题，<code>Method Swizzling</code> 的最佳实现是什么呢？小弟才疏学浅理解的不深刻，找了几篇不错的资源推荐给大家：</p><ul><li><a class="link" target="_blank" rel="noopener" href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411">Objective-C的hook方案（一）: Method Swizzling<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="http://nshipster.com/method-swizzling/">Method Swizzling<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="http://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling">How do I implement method swizzling?<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c">What are the Dangers of Method Swizzling in Objective C?<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://github.com/rentzsch/jrswizzle">JRSwizzle<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们之所以让自己的类继承 <code>NSObject</code> 不仅仅因为苹果帮我们完成了复杂的内存分配问题，更是因为这使得我们能够用上 Runtime 系统带来的便利。深入理解 Runtime 系统的细节更有利于我们利用消息机制写出功能更强大的代码，比如 <code>Method Swizzling</code> 等。</p><p>参考链接</p><ul><li>原文：<a class="link" target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/">Objective-C Runtime<i class="fas fa-external-link-alt"></i></a></li><li>Apple官方文档：<a class="link" target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048">Objective-C Runtime Programming Guide<i class="fas fa-external-link-alt"></i></a></li><li>Apple开源代码：<a class="link" target="_blank" rel="noopener" href="https://opensource.apple.com/source/objc4/">Objective-C Runtime源码<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="http://blog.csdn.net/wzzvictory/article/details/8615569">Objective-C runtime之运行时的基本特点<i class="fas fa-external-link-alt"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="http://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html">Understanding the Objective-C Runtime<i class="fas fa-external-link-alt"></i></a></li></ul></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul class="copyright-info-content"><li class="post-title"><span class="type">本文标题</span>：<span class="content">Objective-C Runtime 详解</span></li><li class="post-author"><span class="type">本文作者</span>：<span class="content">Pin Young</span></li><li class="post-time"><span class="type">创建时间</span>：<span class="content">2021-03-28 00:00:00</span></li><li class="post-link"><span class="type">本文链接</span>：<span class="content">posts/3054.html</span></li><li class="post-license"><span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span></li></ul><div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px"><i class="fa-solid fa-copy"></i></div></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/iOS/">#iOS</a>&nbsp;</li><li class="tag-item"><a href="/tags/Obj-C/">#Obj-C</a>&nbsp;</li><li class="tag-item"><a href="/tags/Runtime/">#Runtime</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/posts/32dd.html"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">前端如何写一个精确的倒计时</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/posts/2a96.html"><span class="title flex-center"><span class="post-nav-title-item">搭建大型源码阅读环境——使用 OpenGrok</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.1.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8ERuntime%E4%BA%A4%E4%BA%92"><span class="nav-number">1.1.3.</span> <span class="nav-text">与Runtime交互</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Objective-C%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">Objective-C源代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSObject%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">NSObject的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runtime%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">Runtime的函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Runtime%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.1.4.</span> <span class="nav-text">Runtime术语</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SEL"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">SEL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#id"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">id</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">Class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ivar"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">Ivar</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IMP"><span class="nav-number">1.1.4.5.</span> <span class="nav-text">IMP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cache"><span class="nav-number">1.1.4.6.</span> <span class="nav-text">Cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Property"><span class="nav-number">1.1.4.7.</span> <span class="nav-text">Property</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF"><span class="nav-number">1.1.5.</span> <span class="nav-text">消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-msgSend%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">objc_msgSend函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E9%9A%90%E8%97%8F%E5%8F%82%E6%95%B0"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">方法中的隐藏参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E5%9C%B0%E5%9D%80"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">获取方法地址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="nav-number">1.1.6.</span> <span class="nav-text">动态方法解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91"><span class="nav-number">1.1.7.</span> <span class="nav-text">消息转发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">重定向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">转发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">1.1.7.3.</span> <span class="nav-text">转发和多继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%BF%E4%BB%A3%E8%80%85%E5%AF%B9%E8%B1%A1-Surrogate-Objects"><span class="nav-number">1.1.7.4.</span> <span class="nav-text">替代者对象(Surrogate Objects)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91%E4%BA%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">1.1.7.5.</span> <span class="nav-text">转发于继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%A5%E5%A3%AE%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F-Non-Fragile-ivars"><span class="nav-number">1.1.8.</span> <span class="nav-text">健壮的实例变量(Non Fragile ivars)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Objective-C-Associated-Objects"><span class="nav-number">1.1.9.</span> <span class="nav-text">Objective-C Associated Objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method-Swizzling"><span class="nav-number">1.1.10.</span> <span class="nav-text">Method Swizzling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.1.11.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2014</span> - 2023 &nbsp;<i class="fas fa-heart icon-animate"></i> &nbsp;<a href="/">Pin Young</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; 总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></div><div class="theme-info info-item">由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/dstansice">零域Lite 1.3.1</a></div><script async defer data-website-id="b3b1feba-ef0f-4367-ba34-6a0152b8749b" src="https://analysis.0skyu.cn/umami.js"></script><div class="icp-info info-item"><div class="theme-info info-item"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12011002021027" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="https://0skyu.cn/beian.png" style="float:left"><p style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">津公网安备 12011002021027号</p></a></div><div class="theme-info info-item"><center><a target="_blank" rel="nofollow" href="https://beian.miit.gov.cn">津ICP备2021004482号-1</a></center></div></div><div class="deploy-info info-item"><a target="_blank" rel="nofollow" href="https://hao.0skyu.cn/">本站由 <span class="tooltip" data-content="腾讯云"><img src="/images/deploy-provider/tencent_cloud.png"></span>提供部署服务</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-top flex-center"><i class="fas fa-arrow-up"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/dark-light-toggle.js"></script><script src="/js/local-search.js"></script><script src="/js/code-block.js"></script><script src="/js/lazyload.js"></script><div class="post-scripts pjax"><script src="/js/post-helper.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/toc.js"></script></div><script src="/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script></body></html>