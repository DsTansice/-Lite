<!DOCTYPE html>
<html lang="zh-CN">
<head><!-- hexo injector head_begin start -->
<link rel="stylesheet" href="/css/bilicard.css?v=372a94e93f">
<!-- hexo injector head_begin end -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="空中有零，零域，分享快乐，音乐，心得，生活，电影，代码，编程，考试，学业，零式的天空，凌空博客，原零空博客，原Tans博客，现零的小屋官方博客，计算机，音乐，电脑，编程，生活，分享">
    <meta name="description" content="一个技术控，爱技术，爱分享，爱音乐">
    <meta name="author" content="Pin Young">
    
    <title>
        
            【Pthreads学习笔记】基本使用 |
        
        零域
    </title>
    
<link rel="stylesheet" href="/css/style.css?v=512d6d2336">

    <link rel="shortcut icon" href="/img/favicon.png?v=96e789c5be">
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css?v=d318f67430">

    
<link rel="stylesheet" href="/font/css/regular.min.css?v=dd643a612d">

    
<link rel="stylesheet" href="/font/css/solid.min.css?v=4abb638a78">

    
<link rel="stylesheet" href="/font/css/brands.min.css?v=bffe02773a">

    
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"0skyu.cn","root":"/","language":"zh-CN","path":"search.xml"}
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#EE5A24","logo":"/img/favicon.png?v=96e789c5be","favicon":"/img/favicon.png?v=96e789c5be","avatar":"img/1.jpg","font_size":null,"font_family":null,"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"header_transparent":false,"background_img":"/img/bg/333.jpg?v=7b42f26db7","description":"Keep writing and Keep loving.","font_color":"#f0d21a","hitokoto":true},"scroll":{"progress_bar":true,"percent":false}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":false,"use":"gitalk","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":"DsTansice","github_admins":"DsTansice","repository":"Null-Comment","client_id":"b109b534b2268088d780","client_secret":"7808e138a1ffbcd9f02bb39cc1ee7fb41828c52f","proxy":null},"twikoo":{"env_id":"twikoo-0skyucn-1gkzaji32bb03146","region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":true},"img_align":"left","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml?v=f2133d50b5" title="零域" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/img/favicon.png?v=96e789c5be">
                </a>
            
            <a class="logo-title" href="/">
               零域
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class href="/">
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class href="/archives">
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class href="/tags">
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class href="/categories">
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class href="/links">
                                友链
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class target="_blank" rel="noopener" href="https://hao.0skyu.cn/">
                                HAO
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class href="/links">友链</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class target="_blank" rel="noopener" href="https://hao.0skyu.cn/">HAO</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">【Pthreads学习笔记】基本使用</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/img/1.jpg?v=e52bd9a478">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">Pin Young</span>
                            
                                <span class="author-label">Lv9</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2016-04-25 09:47:41</span>
        <span class="mobile">2016-04-25 09:47</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2023-02-02 13:39:52</span>
    </span>
    
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Pthreads/">Pthreads</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/Pthreads/">Pthreads</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>4.3k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>17 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>与OpenMP相比，Pthreads的使用相对要复杂一些，需要我们显式的创建、管理、销毁线程，但也正因为如此，我们对于线程有更强的控制，可以更加灵活的使用线程。这里主要记录一下Pthreads的基本使用方法，如果不是十分复杂的使用环境，这些知识应该可以了。本文大部分内容都是参考自<a class="link" target="_blank" rel="noopener" href="http://homes.di.unimi.it/~boccignone/GiuseppeBoccignone_webpage/MatDidatSOD2009_files/pthread-Tutorial.pdf">这里<i class="fas fa-external-link-alt"></i></a>，有兴趣的可以看一下原文。</p>
<span id="more"></span>

<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">hello</span><span class="params">(<span class="type">void</span> * args)</span> {</span><br><span class="line">    <span class="type">long</span>  rank = (<span class="type">long</span>) args;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello form sub thread %ld\n"</span>, rank);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> thread_num = <span class="number">4</span>;</span><br><span class="line">    <span class="type">long</span> thread_index;</span><br><span class="line">    <span class="type">pthread_t</span> * thread_handles;</span><br><span class="line"></span><br><span class="line">    thread_handles =(<span class="type">pthread_t</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span> ) * thread_num);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(thread_index = <span class="number">0</span>; thread_index &lt; thread_num; thread_index++) {</span><br><span class="line">        pthread_create(&amp;thread_handles[thread_index], <span class="literal">NULL</span>, hello, (<span class="type">void</span> *)thread_index);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello from main thread\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(thread_index = <span class="number">0</span>; thread_index &lt; thread_num; thread_index++) {</span><br><span class="line">        pthread_join(thread_handles[thread_index], <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(thread_handles);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>编译程序, 需要加上 ‘-lpthread’</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o helloworld helloworld.c -lpthread</span><br></pre></td></tr></table></figure>

<p>一种可能的输出结果</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello from main thread</span><br><span class="line">Hello form sub thread 2</span><br><span class="line">Hello form sub thread 3</span><br><span class="line">Hello form sub thread 1</span><br><span class="line">Hello form sub thread 0</span><br></pre></td></tr></table></figure>

<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>Pthreads使用 <code>pthread_create</code> 函数来创建线程, 函数原型如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">( <span class="type">pthread_t</span> *               thread, </span></span><br><span class="line"><span class="params">                    <span class="type">const</span> <span class="type">pthread_attr_t</span> *    attr, </span></span><br><span class="line"><span class="params">                    <span class="type">void</span> *                    (*start_routine) (<span class="type">void</span> *), </span></span><br><span class="line"><span class="params">                    <span class="type">void</span> *                    arg</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>参数说明:<br><strong>thread</strong><br>　　<small>指向执行线程标识符的指针, 通过该变量来控制线程</small><br><strong>attr</strong><br>　　<small>设置线程属性, 如果为NULL, 则使用默认的属性</small><br><strong>start_routine</strong><br>　　<small>线程运行函数的起始地址</small><br><strong>arg</strong><br>　　<small>运行函数的参数, 这里使用 <code>void*</code>来作为参数类型, 以便可以向运行函数中传递任意类型的参数, 当然需要在运行函数中将参数转换为其原来的类型.</small><br><strong>返回值</strong><br>　　<small>如果创建线程成功会返回0, 否则返回错误码.</small>  </p>
<p>下面是一个使用示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span> {</span><br><span class="line">    <span class="type">int</span> * incoming = (<span class="type">int</span> *)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"this is in pthread and arg is %d\n"</span>, *incoming);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello_world</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">pthread_t</span> thread_id ;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">63</span>;</span><br><span class="line">    pthread_create(&amp;thread_id, <span class="literal">NULL</span>, thread_function, &amp;value);</span><br><span class="line">    <span class="comment">// 等待线程执行完</span></span><br><span class="line">    pthread_join(thread_id, <span class="literal">NULL</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>在上面的代码中, 在程序最后加上了 <code>pthread_join</code> 函数, 用来完成线程间的同步, 即主线程等待指定的线程(在上面的代码中是 thread_id 对应的线程)执行完再往下执行. 在下面会详细介绍该函数.</p>
<h2 id="Join-和-Detach"><a href="#Join-和-Detach" class="headerlink" title="Join 和 Detach"></a>Join 和 Detach</h2><h3 id="Join-合并"><a href="#Join-合并" class="headerlink" title="Join(合并)"></a>Join(合并)</h3><p><code>pthread_join </code> 可以用于线程之间的同步, 当一个线程对另一个线程调用了join操作之后, 该线程会处于阻塞状态, 直到另外一个线程执行完毕. 下面是一个示意图:<br><img lazyload alt="image" data-src="/images/pthread/pthread_join.png"></p>
<p>下面是 <code>pthread_join</code>的函数原型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">( <span class="type">pthread_t</span> thread, </span></span><br><span class="line"><span class="params">                  <span class="type">void</span> **   retval</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>参数说明:<br><strong>thread</strong><br>　　<small>线程标识符, 用来指定等待哪个线程</small><br><strong>retaval</strong><br>　　<small>用来存储等待线程的返回值</small>  </p>
<p>下面是通过获取函数返回值的一个示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">p_result</span><span class="params">(<span class="type">void</span> * arg)</span> {</span><br><span class="line">    <span class="type">char</span> * m = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">3</span>);</span><br><span class="line">    m[<span class="number">0</span>] = <span class="string">'A'</span>;</span><br><span class="line">    m[<span class="number">1</span>] = <span class="string">'B'</span>;</span><br><span class="line">    m[<span class="number">2</span>] = <span class="string">'C'</span>;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_get_result</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">pthread_t</span> thread_id;</span><br><span class="line">    <span class="type">void</span> * exit_status ;</span><br><span class="line">    pthread_create(&amp;thread_id, <span class="literal">NULL</span>, p_result, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thread_id, &amp; exit_status);</span><br><span class="line">    <span class="type">char</span> * m = (<span class="type">char</span>* ) exit_status;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"m is %s\n"</span>, m);</span><br><span class="line">    <span class="built_in">free</span>(m);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>在 <code>p_result</code> 函数中为了使线程执行完, 我们还可以访问到变量 m 中的数据, m 的内存采用动态分配的方式, 如果静态分配, 即如 <code>char m[3]</code> 的形式, 那么在函数执行完就会清空 m 的值, 我们就无法获得想要的结果.</p>
<p>对于一个线程来说, 其终止方式有两种: 执行完线程函数或者自身调用 <code>pthread_exit(void *)</code>, 如果线程通过执行完线程函数而终止的, 那么其他线程通过<code>pthread_join</code>获得的线程返回值就是线程函数的返回值(如上面的例子), 如果线程是通过 <code>pthread_exit(void *)</code> 方式结束的线程, 其线程返回值就是 <code>pthread_exit</code> 传入的参数, 下面是一个示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">p_exit_result</span><span class="params">(<span class="type">void</span> * arg)</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"print before pthread_exit\n"</span>);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)<span class="number">10L</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"print after pthread_exit\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_exit_result</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">pthread_t</span> thread_id;</span><br><span class="line">    <span class="type">void</span> * exit_status ;</span><br><span class="line">    pthread_create(&amp;thread_id, <span class="literal">NULL</span>, p_exit_result, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thread_id, &amp; exit_status);</span><br><span class="line">    <span class="type">long</span> m = (<span class="type">long</span> ) exit_status;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"m is %ld\n"</span>, m);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>下面是输出结果</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print before pthread_exit</span><br><span class="line">m is 10</span><br></pre></td></tr></table></figure>

<p>一般来说, 使用 Pthreads 创建的线程默认应该是可 join 的, 但是并不是所有实现都会这样, 所以必要情况下, 我们可以在创建线程时, 显式的指定线程是可 join 的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> thread_id;</span><br><span class="line"><span class="type">pthread_attr_t</span> attr;</span><br><span class="line">pthread_attr_init(&amp;attr);</span><br><span class="line">pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line">pthread_create(&amp;thread_id, &amp;attr, work, (<span class="type">void</span> *)arg);</span><br><span class="line">pthread_attr_destroy(&amp;attr);</span><br><span class="line">pthread_join(thread_id, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Detach-分离"><a href="#Detach-分离" class="headerlink" title="Detach(分离)"></a>Detach(分离)</h3><p>对于可 join 的线程, 只有当其他线程对其调用了 <code>pthread_join</code> 之后, 该线程才会释放所占用的资源(例如线程所对应的标识符pthread_t, 线程的返回值信息), 如果想要系统回收线程的资源, 而不是通过调用<code>pthread_join</code>回收资源(会阻塞线程), 我们可以将线程设置为 <code>DETACHED (分离的)</code>, 有三种方式将线程设为 <code>detached</code>的</p>
<ul>
<li>创建线程时指定线程的 <code>detach</code> 属性: <code>pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</code></li>
<li>通过在子线程中调用 <code>pthread_detach(pthread_self());</code> </li>
<li>在主线程中调用 <code>pthread_detach(thread_id);</code>(非阻塞, 执行完会立即会返回),</li>
</ul>
<p>通过上面的方式将线程设为 <code>detached</code>, 线程运行结束后会自动释放所有资源.</p>
<h2 id="Mutex-互斥锁"><a href="#Mutex-互斥锁" class="headerlink" title="Mutex(互斥锁)"></a>Mutex(互斥锁)</h2><p>互斥锁用来保护共享变量, 它可以保证某个时间内只有一个线程访问共享变量, 下面是使用互斥锁的具体步骤</p>
<ul>
<li>声明 <code>pthread_mutex_t</code> (互斥锁类型) 类型的变量</li>
<li>调用 <code>pthread_mutex_init()</code> 来初始化变量</li>
<li>在访问共享变量之前, 调用 <code>pthread_mutex_lock()</code> 获得互斥锁, 如果互斥锁被其他线程占用, 该线程会处于等待状态</li>
<li>访问完共享变量之后, 调用 <code>pthread_mutex_unlock()</code> 释放互斥锁, 以便其他线程使用</li>
<li>程序执行完后调用 <code>pthread_mutex_destroy()</code>释放资源.</li>
</ul>
<p>创建互斥锁有两种方式: 静态方式和动态方式. 静态方式是使用宏 <code>PTHREAD_MUTEX_INITIALIZER</code> 来初始化锁, 如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>
<p>动态方式是调用 <code>pthread_mutex_init</code> 函数动态初始锁, 下面是该函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> * attr)</span></span><br></pre></td></tr></table></figure>
<p>下面是使用互斥锁的一个示例(使用动态方式):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"><span class="type">int</span> share_data;</span><br><span class="line"><span class="type">void</span> * <span class="title function_">p_lock</span><span class="params">(<span class="type">void</span> * arg)</span> {</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span>; i++) {</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        share_data++;</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_lock</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">pthread_t</span> thread_id;</span><br><span class="line">    <span class="type">void</span> *exit_status;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;thread_id, <span class="literal">NULL</span>, p_lock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Shared integer's value = %d\n"</span>, share_data);</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    pthread_join(thread_id, &amp; exit_status);</span><br><span class="line">    pthread_mutex_destroy(&amp;lock);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>下是使用互斥量的几个注意点:</p>
<ul>
<li>使用 lock 和 unlock 一个互斥锁时, 一定要先初始化该互斥锁</li>
<li>释放互斥锁的线程必须是获得互斥锁的那个线程</li>
<li>当 destroy 互斥锁的时候, 不该有线程还在使用这个互斥锁</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>在动态创建互斥锁时, 我们可以传入一个锁属性变量 <code>pthread_mutexattr_t</code> 来初始化锁的属性, 通过下面两个函数来初始化和销毁该属性对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_init</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_destroy</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure>
<p>然后可以调用下面的方法对属性进行设置</p>
<p><strong>范围</strong><br>可以指定互斥锁是进程之间的同步还是进程内的同步, 下面是对应的两个锁的范围(scope)</p>
<ul>
<li><code>PTHREAD_PROCESS_SHARE</code>: 进程间同步</li>
<li><code>PTHREAD_PROCESS_PRIVATE</code>: 进程内同步, 默认值</li>
</ul>
<p>通过调用下面的函数可以设置和获取锁的范围</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_getpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> * <span class="keyword">restrict</span> attr, <span class="type">int</span> *<span class="keyword">restrict</span> pshared)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_setpshared</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> pshared)</span>; </span><br></pre></td></tr></table></figure>

<p><strong>类型</strong><br>互斥锁的类型有以下几种取值方式(为了兼容性, 一个类型可能有多个名称):</p>
<ul>
<li><strong><code>PTHREAD_MUTEX_TIMED_NP / PTHREAD_MUTEX_NORMAL /  PTHREAD_MUTEX_DEFAULT</code></strong> : 缺省值, 也就是普通锁. 当一个线程获得锁之后, 其余请求锁的线程将形成一个等待队列, 并在加锁线程解锁后按照优先级获得锁. 这种策略保证了资源分配的公正性.</li>
<li><strong><code>PTHREAD_MUTEX_RECURSIVE_NP /  PTHREAD_MUTEX_RECURSIVE</code></strong> : 嵌套锁, 允许一个线程对同一个锁成功获得多次, 并通过多次 unlock 来解锁. 如果是不同线程请求, 则在加锁线程解锁后重新竞争.</li>
<li><strong><code>PTHREAD_MUTEX_ERRORCHECK_NP / PTHREAD_MUTEX_ERRORCHECK</code></strong>: 如果同一个线程请求同一个锁，则返回<code>EDEADLK</code>，否则与<code>PTHREAD_MUTEX_TIMED_NP</code>类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁</li>
<li><strong><code>PTHREAD_MUTEX_ADAPTIVE_NP</code></strong>: 适应锁，动作最简单的锁类型，仅等待解锁后重新竞争</li>
</ul>
<p>可以使用下面的函数获取和设置锁的类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_gettype</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> *type)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_settype</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> type)</span>;</span><br></pre></td></tr></table></figure>


<h2 id="Condition-Variables-条件变量"><a href="#Condition-Variables-条件变量" class="headerlink" title="Condition Variables(条件变量)"></a>Condition Variables(条件变量)</h2><p>条件变量对应的数据类型为 <code>pthread_cond_t</code>, 通过使用条件变量, 可以使线程在某个 <strong>特定条件</strong> 或者 <strong>事件</strong> 发生之前处于挂起状态. 当事件或者条件发生之后, 另一个线程可以通过信号来唤起挂起的线程. 条件变量主要使用下面几个函数</p>
<p><strong>初始化(init)</strong><br>和互斥锁一样, 条件变量也有两种初始化方式: 静态方式和动态方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER; </span><br><span class="line"><span class="comment">// 动态, 成功返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>销毁(destroy)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>等待函数(wait)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">( <span class="type">pthread_cond_t</span> *   <span class="keyword">restrict</span> cond, </span></span><br><span class="line"><span class="params">                       <span class="type">pthread_mutex_t</span> *  <span class="keyword">restrict</span> mutex )</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">( <span class="type">pthread_cond_t</span> *         <span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">                            <span class="type">pthread_mutex_t</span> *        <span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="keyword">struct</span> timespec *  <span class="keyword">restrict</span> abstime )</span>;</span><br></pre></td></tr></table></figure>

<p>通过调用 wait 函数, 线程会处于挂起状态. 其中 <code>pthread_cond_timedwait</code> 的含义为: 如果在 <code>abstime</code> 时间内(系统时间小于abstime), 线程没有被唤醒, 那么线程就会结束等待, 同时返回 <code>ETIMEDOUT</code> 错误.</p>
<p><strong>唤醒函数(signal)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>; </span><br></pre></td></tr></table></figure>
<p>singal 函数一次只能唤醒一个线程, 而 broadcast 会唤醒所有在当前条件变量下等待的线程. </p>
<p>下面是条件变量的具体使用, 首先一个线程会根据条件来确实是否需要处于挂起状态, 即如下面的形式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag == <span class="number">0</span>){</span><br><span class="line">    pthread_cond_wait(...);</span><br><span class="line">} </span><br></pre></td></tr></table></figure>
<p>如果flag不为0, 那么线程就不进入等待状态, 否则就挂起线程, 等待flag不为0(满足条件了, 可以往下执行)时被唤醒. 唤醒该线程的代码如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">pthread_cond_signal(...);</span><br></pre></td></tr></table></figure>
<p>下面考虑一下这种情况, 首先 <code>flag = 0</code>, 当线程1执行到 <code>if(flag == 0)</code> 时, 发现不满足继续往下执行的条件, 即将进入挂起状态, 就在其刚要挂起的时候(还没挂起), 线程2执行了唤醒线程1的代码(修改flag的值, 唤醒线程1), 假设线程2执行完上述操作之后, 线程1仍然还没有挂起, 所以 <code>pthread_cond_signal</code> 并没有起到作用. 此后线程1终于进入了挂起状态, 等待线程2的唤醒, 而线程2则认为它已经唤醒了线程1, 让其往下执行了. 此时问题就来了, 如果线程2不再执行唤醒线程1的操作, 那么线程1就会永远处于挂起状态. 为了解决这种情况, 需要满足从判断 <code>flag==0</code> 到 <code>pthread_cond_wait()</code> 执行,  <code>flag</code> 的值不能发生变化,并且不能提前执行唤醒操作. 为了实现这种需求, 我们需要加一个锁操作,<br>等待代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">0</span>){</span><br><span class="line">    pthread_cond_wait(...);</span><br><span class="line">} </span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p>唤醒代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">pthread_cond_signal(&amp;condition);</span><br></pre></td></tr></table></figure>
<p>我们看到 <code>pthread_cond_wait</code> 的函数原型中第一个参数为条件变量, 第二个参数为互斥锁, 之所以需要传入互斥锁, 是因为如果不传入互斥锁, 当线程进入挂起状态时, 就无法释放掉该互斥锁, 而其他线程就无法获得该互斥锁,就没办法更新<code>flag</code>的值, 也无法唤醒线程1. 线程1就会永远处于挂起状态, 线程2就会永远处于请求互斥锁的状态. 所以当线程1进入挂起状态时需要释放掉互斥锁, 被唤醒之后再重新获得互斥锁, 即 <code>pthread_cond_wait</code> 可以看成下面的操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">wait_on_signal(&amp;condition);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p>所有一个条件变量总是和一个互斥锁关联.<br>下面再来看一下等待代码, 在某些特定情况下, 即使没有线程调用 <code>pthread_cond_signal</code>函数, ‘pthread_cond_wait’ 函数也有可能返回(具体解释可以看看<a class="link" target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Spurious_wakeup"> spurious wakeup<i class="fas fa-external-link-alt"></i></a>), 但是此时条件并不满足, 如果程序往下执行, 那么就可能会出错. 所以为了避免这种情况, 即使线程被唤醒了, 也应该再检查一下条件是否满足, 即使用 while 循环代替 if 判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span>(flag == <span class="number">0</span>){</span><br><span class="line">    pthread_cond_wait(...);</span><br><span class="line">} </span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p>下面是一个使用示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> is_zero;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">int</span> con_share_data = <span class="number">32767</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">p_condition</span><span class="params">(<span class="type">void</span> * arg)</span> {</span><br><span class="line">    <span class="keyword">while</span>(con_share_data &gt; <span class="number">0</span>) {</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        con_share_data--;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    }</span><br><span class="line">    pthread_cond_signal(&amp;is_zero);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_condition</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">pthread_t</span> thread_id;</span><br><span class="line">    <span class="type">void</span> *exit_status;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    pthread_cond_init(&amp;is_zero, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;thread_id, <span class="literal">NULL</span>, p_condition, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span>(con_share_data != <span class="number">0</span>) {</span><br><span class="line">        pthread_cond_wait(&amp; is_zero, &amp;mutex);</span><br><span class="line">    }</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_join(thread_id, &amp;exit_status);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;is_zero);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="Semaphores-信号量"><a href="#Semaphores-信号量" class="headerlink" title="Semaphores(信号量)"></a>Semaphores(信号量)</h2><p>信号量本质上可以看做是一个计数器, 它主要有两种操作, 第一类操作为 down 或者 wait – <code>sem_wait(...)</code>, 目的是为了减小计数器(将信号俩减1), 另一类为 up 或者 signal – <code>sem_post(...)</code> , 目的是为了增大计数器(将信号量加1). 当线程调用 <code>sem_wait()</code> 时, 如果信号量的值大于0, 那么只会把信号量减1, 线程会继续往下执行. 如果信号量的值为0, 那么线程就会进入阻塞状态, 直到另外一个线程执行了 <code>sem_post()</code> 操作, 对信号量进行了增操作, 该线程才会继续往下执行.</p>
<p>信号量主要用于对一些稀缺资源的同步, 什么叫做稀缺资源, 就是说这个资源只有有限的几个, 但是又多于一个, 在某一个时刻, 可以供有限的几个线程使用, 但又不是全部线程使用. 如果将信号量初始化为1, 那么该信号量就等同于互斥锁了, 因此一次只能有一个线程获得信号量的资源, 如果其他线程想要获得, 必须等该线程对信号量进行增操作. 举个例子说: 有10个人去银行办理业务, 但是银行只有4个窗口(信号量初始化为4), 所以前4个人到了银行就可以办理业务, 但是第5个人之后就必须要等待, 等前面的某个人办理完业务(增加信号量), 空出窗口来. 而当第5个人去办理业务时, 空出的窗口又被占用了(减小信号量), 剩下的人还是要等待. 信号量在执行过程中和上述例子不同的一点是, 当有空余的资源出现时, 线程并不一定按照 FIFO(先进先出) 的顺序来获取资源, 而有可能是随机一个线程获得资源. </p>
<p>下面是信号量相关的函数<br><strong>类型</strong><br>信号量的类型是 <code>sem_t</code>, 需要引入头文件 <code>#include &lt;semaphore.h&gt;</code></p>
<p><strong>初始化和销毁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>
<p>init 函数的第二个参数用来标识信号量的范围: 0 表示一个进程中线程间共享, 非0 表示进程间共享. 第三个参数就是信号量的可用数量.</p>
<p><strong>wait和signal</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>
<p>下面是一个使用示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sem_share_data = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// use like a mutex</span></span><br><span class="line"><span class="type">sem_t</span> binary_sem; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">p_sem</span><span class="params">(<span class="type">void</span> * arg)</span> {</span><br><span class="line">    sem_wait(&amp;binary_sem);     <span class="comment">// 减少信号量</span></span><br><span class="line">    <span class="comment">// 在这里使用共享数据; </span></span><br><span class="line">    sem_post(&amp;binary_sem);     <span class="comment">// 增加信号量</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_sem</span><span class="params">()</span> {</span><br><span class="line">    sem_init(&amp;binary_sem, <span class="number">0</span>, <span class="number">1</span>);   <span class="comment">// 信号量初始化为1, 当初互斥锁使用</span></span><br><span class="line">    <span class="comment">// 在这里创建线程</span></span><br><span class="line">    sem_wait(&amp;binary_sem);</span><br><span class="line">    <span class="comment">// 在这里使用共享变量</span></span><br><span class="line">    sem_post(&amp;binary_sem);</span><br><span class="line">    <span class="comment">// 在这里join线程</span></span><br><span class="line">    sem_destroy(&amp;binary_sem);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="Reader-x2F-Writer-Locks-读写锁"><a href="#Reader-x2F-Writer-Locks-读写锁" class="headerlink" title="Reader/Writer Locks 读写锁"></a>Reader/Writer Locks 读写锁</h2><p>对于读写锁来说, 多个线程可以同时获得读锁, 但某一个时间内, 只有一个线程可以获得写锁. 如果已经有线程获得了<strong>读锁</strong>, 则任何请求<strong>写锁</strong>的线程将被阻塞在写锁函数的调用上, 同时如果线程已经获得了<strong>写锁</strong>, 那么任何请求<strong>读锁</strong>或者<strong>写锁</strong> 的线程都会被阻塞. 下面是读写锁的基本函数:</p>
<p><strong>锁类型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> </span><br></pre></td></tr></table></figure>

<p><strong>初始化/销毁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>读锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>写锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>释放锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>; </span><br></pre></td></tr></table></figure>

<p>下面是一个使用示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rw_lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">p_rwlock</span><span class="params">(<span class="type">void</span> * arg)</span> {</span><br><span class="line">    pthread_rwlock_rdlock(&amp;rw_lock);</span><br><span class="line">    <span class="comment">// 读取共享变量</span></span><br><span class="line">    pthread_rwlock_unlock(&amp;rw_lock);</span><br><span class="line">    </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">test_rwlock</span><span class="params">()</span> {</span><br><span class="line">    pthread_rwlock_init(&amp;rw_lock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    pthread_rwlock_wrlock(&amp;rw_lock);</span><br><span class="line">    <span class="comment">// 修改共享变量</span></span><br><span class="line">    pthread_rwlock_unlock(&amp;rw_lock);</span><br><span class="line">    <span class="comment">// join线程</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rw_lock);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a class="link" target="_blank" rel="noopener" href="http://homes.di.unimi.it/~boccignone/GiuseppeBoccignone_webpage/MatDidatSOD2009_files/pthread-Tutorial.pdf">pthread Tutoriaed Tutorial<i class="fas fa-external-link-alt"></i></a><br><a class="link" target="_blank" rel="noopener" href="https://computing.llnl.gov/tutorials/pthreads/#PassingArguments">POSIX Threads Programming<i class="fas fa-external-link-alt"></i></a><br><a class="link" target="_blank" rel="noopener" href="http://blog.csdn.net/jw903/article/details/31738877">Linux线程-互斥锁pthread_mutex_t<i class="fas fa-external-link-alt"></i></a><br><a class="link" target="_blank" rel="noopener" href="http://www.cnblogs.com/mywolrd/archive/2009/02/05/1930707.html#topic_not_covered">Pthread：POSIX 多线程程序设计<i class="fas fa-external-link-alt"></i></a></p>
<p>下面列出一些学习资料，如果想深入学习Pthreads可以看下这些资料(摘自<a class="link" target="_blank" rel="noopener" href="http://www.cnblogs.com/mywolrd/archive/2009/02/05/1930707.html#topic_not_covered">POSIX 多线程程序设计<i class="fas fa-external-link-alt"></i></a>)：<br><a class="link" target="_blank" rel="noopener" href="http://download.csdn.net/detail/future_fighter/992248">Pthreads多线程编程指南<i class="fas fa-external-link-alt"></i></a><br><a class="link" target="_blank" rel="noopener" href="http://download.csdn.net/detail/future_fighter/992239">Programing with POSIX thread<i class="fas fa-external-link-alt"></i></a><br><a class="link" target="_blank" rel="noopener" href="http://download.csdn.net/detail/future_fighter/992213">Pthread Primer<i class="fas fa-external-link-alt"></i></a></p>

            </div>

            
                <div class="post-copyright-info">
                    
<div class="article-copyright-info-container">
    <ul class="copyright-info-content">
        <li class="post-title">
            <span class="type">本文标题</span>：<span class="content">【Pthreads学习笔记】基本使用</span>
        </li>
        <li class="post-author">
            <span class="type">本文作者</span>：<span class="content">Pin Young</span>
        </li>
        <li class="post-time">
            <span class="type">创建时间</span>：<span class="content">2016-04-25 09:47:41</span>
        </li>
        <li class="post-link">
            <span class="type">本文链接</span>：<span class="content">posts/82da.html</span>
        </li>
        <li class="post-license">
            <span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span>
        </li>
    </ul>
    <div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">#学习笔记</a>&nbsp;
                        </li>
                    
                        <li class="tag-item">
                            <a href="/tags/Pthreads/">#Pthreads</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev" rel="prev" href="/posts/39d0.html">
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">Meteor项目部署笔记</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next" rel="next" href="/posts/20e0.html">
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Atom 的炫酷插件 activate-power-mode</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HelloWorld"><span class="nav-number">2.</span> <span class="nav-text">HelloWorld</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">创建线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Join-%E5%92%8C-Detach"><span class="nav-number">4.</span> <span class="nav-text">Join 和 Detach</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Join-%E5%90%88%E5%B9%B6"><span class="nav-number">4.1.</span> <span class="nav-text">Join(合并)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Detach-%E5%88%86%E7%A6%BB"><span class="nav-number">4.2.</span> <span class="nav-text">Detach(分离)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mutex-%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text">Mutex(互斥锁)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7"><span class="nav-number">5.1.</span> <span class="nav-text">属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Condition-Variables-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">6.</span> <span class="nav-text">Condition Variables(条件变量)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphores-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">7.</span> <span class="nav-text">Semaphores(信号量)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reader-x2F-Writer-Locks-%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">8.</span> <span class="nav-text">Reader/Writer Locks 读写锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="nav-number">9.</span> <span class="nav-text">参考文章</span></a></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            ©
            
                <span>2014</span> -
            
            2023
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">Pin Young</a>
            
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    访问人数&nbsp;<span id="busuanzi_value_site_uv"></span> 
                
                
                    总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/dstansice">零域Lite 1.3.1</a>
        </div>
        
        
        <script async defer data-website-id="b3b1feba-ef0f-4367-ba34-6a0152b8749b" src="https://analysis.0skyu.cn/umami.js"></script>
         
            <div class="icp-info info-item">
            <div class="theme-info info-item">
                <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12011002021027" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"><img src="https://0skyu.cn/beian.png" style="float:left;"><p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">津公网安备 12011002021027号</p></a> 
                </div>
                 <div class="theme-info info-item">
               <center> <a target="_blank" rel="nofollow" href="https://beian.miit.gov.cn">
                    津ICP备2021004482号-1
                </a></center>
                </div>
                
            </div>
        
        
            <div class="deploy-info info-item">
                
                    <a target="_blank" rel="nofollow" href="https://hao.0skyu.cn/">
                
                    本站由 <span class="tooltip" data-content="腾讯云"><img src="/images/deploy-provider/tencent_cloud.png?v=9693e72d12"></span> 提供部署服务
                
                    </a>
                
            </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center" href="/atom.xml" target="_blank">
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input">
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js?v=cbd27e8569"></script>

<script src="/js/main.js?v=3ab50fd2bb"></script>

<script src="/js/header-shrink.js?v=0418df63d7"></script>

<script src="/js/back2top.js?v=139ceb0539"></script>

<script src="/js/dark-light-toggle.js?v=f21816b072"></script>





    
<script src="/js/local-search.js?v=0ce0b1d637"></script>




    
<script src="/js/code-block.js?v=63706df46d"></script>




    
<script src="/js/lazyload.js?v=f1e4b68ec3"></script>



<div class="post-scripts pjax">
    
        
<script src="/js/post-helper.js?v=34bd3800c9"></script>

        
            
<script src="/js/libs/anime.min.js?v=864a144dbb"></script>

        
        
            
<script src="/js/toc.js?v=037238356c"></script>

        
    
</div>


    
<script src="/js/libs/pjax.min.js?v=cdf1c08dca"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
