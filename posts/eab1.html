<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="空中有零，零域，分享快乐，音乐，心得，生活，电影，代码，编程，考试，学业，零式的天空，凌空博客，原零空博客，原Tans博客，现零的小屋官方博客，计算机，音乐，电脑，编程，生活，分享"><meta name="description" content="一个技术控，爱技术，爱分享，爱音乐"><meta name="author" content="Pin Young"><title>【MIC学习笔记】向量化 | 零域</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/img/favicon.png"><link rel="stylesheet" href="/font/css/fontawesome.min.css"><link rel="stylesheet" href="/font/css/regular.min.css"><link rel="stylesheet" href="/font/css/solid.min.css"><link rel="stylesheet" href="/font/css/brands.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"0skyu.cn",root:"/",language:"zh-CN",path:"search.xml"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!0,init_open:!0},style:{primary_color:"#EE5A24",logo:"/img/favicon.png",favicon:"/img/favicon.png",avatar:"img/1.jpg",font_size:null,font_family:null,hover:{shadow:!0,scale:!1},first_screen:{enable:!0,header_transparent:!1,background_img:"/img/bg/333.jpg",description:"Keep writing and Keep loving.",font_color:"#f0d21a",hitokoto:!0},scroll:{progress_bar:!0,percent:!1}},local_search:{enable:!0,preload:!0},code_copy:{},code_block:{tools:{enable:!0,style:"default"},highlight_theme:"default"},side_tools:{},pjax:{enable:!0},lazyload:{enable:!0},comment:{enable:!1,use:"gitalk",valine:{appid:null,appkey:null,server_urls:null,placeholder:null},gitalk:{github_id:"DsTansice",github_admins:"DsTansice",repository:"Null-Comment",client_id:"b109b534b2268088d780",client_secret:"7808e138a1ffbcd9f02bb39cc1ee7fb41828c52f",proxy:null},twikoo:{env_id:"twikoo-0skyucn-1gkzaji32bb03146",region:null,version:"1.6.8"},waline:{server_url:null,reaction:!1,version:2}},post:{author_label:{enable:!0,auto:!0,custom_label_list:["Trainee","Engineer","Architect"]},word_count:{enable:!0,wordcount:!0,min2read:!0},img_align:"left",copyright_info:!0},version:"3.6.1"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"},KEEP.language_code_block={copy:"复制代码",copied:"已复制",fold:"折叠代码块",folded:"已折叠"},KEEP.language_copy_copyright={copy:"复制版权信息",copied:"已复制",title:"原文标题",author:"原文作者",link:"原文链接"}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="零域" type="application/atom+xml">
</head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/"><img src="/img/favicon.png"> </a><a class="logo-title" href="/">零域</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item"><a target="_blank" rel="noopener" href="https://hao.0skyu.cn/">HAO</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li><li class="drawer-menu-item flex-center"><a target="_blank" rel="noopener" href="https://hao.0skyu.cn/">HAO</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="post-page-container"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">【MIC学习笔记】向量化</span></div><div class="article-header"><div class="avatar"><img src="/img/1.jpg"></div><div class="info"><div class="author"><span class="name">Pin Young</span> <span class="author-label">Lv9</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-calendar-plus"></i>&nbsp; <span class="pc">2015-12-27 16:58:31</span> <span class="mobile">2015-12-27 16:58</span> </span><span class="article-update-date article-meta-item"><i class="fas fa-file-pen"></i>&nbsp; <span class="pc">2023-02-02 13:39:50</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/MIC/">MIC</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>&nbsp;</li><li>| <a href="/tags/MIC/">MIC</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>3.2k 字</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>16 分钟</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content keep-markdown-body"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>向量化简单的说就是使用SIMD指令, 来实现使用一条指令同时处理多个数据, MIC中具有32个长度为512位的向量处理单元, 每个向量处理单元可以处理16个32位或者8个64位的数据. 这里主要记录一下MIC向量化的使用方式以及一些向量指令的作用.</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>MIC中使用下面的数据类型作为执行向量函数的操作数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__m512, __m512i  __m512d</span><br></pre></td></tr></table></figure><p>下面是它们的各自的作用:</p><ul><li><code>__m512</code> - 处理单精度向量(float32 vector)</li><li><code>__m512d</code> - 处理双精度向量(float64 vector)</li><li><code>__m512i</code> - 处理整形向量, 包括32位和64位整形(int32&#x2F;int64)<span id="more"></span> 上面的数据类型直接映射到向量寄存器上(vector registers), 除此之外还有一种数据类型__mmask16 - is an unsigned short type associated with the mask register values.<br>我们可以使用 <code>Load Intrinsics</code>(为向量赋值) 和 <code>Store Intrinsics</code> (保存向量的值) 实现向量的存取. 下面是一个示例</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test_load_store</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用int32_t和int64_t 需要引入stdint.h</span></span><br><span class="line">    <span class="type">int32_t</span> *arr_int32;</span><br><span class="line">    <span class="type">int64_t</span> *arr_int64;</span><br><span class="line">    <span class="type">int</span> i, n = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要使用_mm_malloc分配内存, 并且以64位对齐, 否则可能出现错误</span></span><br><span class="line">    arr_int32 = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">int32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line">    arr_int64 = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">int64_t</span>) * n, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr_int32[i] = i;</span><br><span class="line">        arr_int64[i] = i + n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> offload target(mic) inout(arr_int32:length(n)) inout(arr_int64:length(n))</span></span><br><span class="line">    &#123;</span><br><span class="line">        __m512i m_32, m_64;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将arr_int32 中0-15个元素加载到 m_32 中</span></span><br><span class="line">        m_32 = _mm512_load_epi32(arr_int32);</span><br><span class="line">        <span class="comment">// 将arr_int32 中16-31个元素加载到 m_32 中</span></span><br><span class="line">        m_32 = _mm512_load_epi32(arr_int32 + <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将arr_int64中0-7个元素加载到 m_64 中</span></span><br><span class="line">        m_64 = _mm512_load_epi64(arr_int64);</span><br><span class="line">        <span class="comment">// 将arr_int64中8-15个元素加载到 m_64 中</span></span><br><span class="line">        m_64 = _mm512_load_epi64(arr_int64 + <span class="number">8</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将m_32 中的值保存到arr_int32 的0-15个元素中</span></span><br><span class="line">        _mm512_store_epi32(arr_int32, m_32);</span><br><span class="line">        <span class="comment">// 将m_64 中的值保存到arr_int32 的16-31个元素中</span></span><br><span class="line">        _mm512_store_epi32(arr_int32 + <span class="number">16</span>, m_32);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将m_64 中的值保存到arr_int64的0-7个元素</span></span><br><span class="line">        _mm512_store_epi64(arr_int64, m_64);</span><br><span class="line">        <span class="comment">// 将m_64 中的值保存到arr_int64的8-15个元素中</span></span><br><span class="line">        _mm512_store_epi64(arr_int64 + <span class="number">8</span>, m_64);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用_mm_malloc分配的内存需要_mm_free来释放</span></span><br><span class="line">    _mm_free(arr_int32);</span><br><span class="line">    _mm_free(arr_int64);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向量化函数-Intrinsics"><a href="#向量化函数-Intrinsics" class="headerlink" title="向量化函数(Intrinsics)"></a>向量化函数(Intrinsics)</h2><p>这里主要记录一些编译器提供的向量化函数, 完整的函数集可以在<a class="link" target="_blank" rel="noopener" href="https://software.intel.com/en-us/node/523386">这里<i class="fas fa-external-link-alt"></i></a>或者<a class="link" target="_blank" rel="noopener" href="http://scc.ustc.edu.cn/zlsc/tc4600/intel/2015.1.133/compiler_c/">这里<i class="fas fa-external-link-alt"></i></a>查询</p><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><p>MIC中提供了加,减, 乘 三种算术运算函数, 这里以32位整型的加法为例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;immintrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mic_add</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> *arr_a, *arr_b, *arr_c;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, n = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    arr_a = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line">    arr_b = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line">    arr_c = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr_a[i] = i;</span><br><span class="line">        arr_b[i] = n + i; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> offload target(mic) in(arr_a:length(n)) in(arr_b:length(n)) out(arr_c:length(n))</span></span><br><span class="line">    &#123;</span><br><span class="line">        __m512i m_a, m_b, m_c;</span><br><span class="line">        m_a = _mm512_load_epi32(arr_a);</span><br><span class="line">        m_b = _mm512_load_epi32(arr_b);</span><br><span class="line">        m_c = _mm512_add_epi32(m_a, m_b);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 减法</span></span><br><span class="line">        <span class="comment">//m_c = _mm512_sub_epi32(m_a, m_b);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 乘法 _mm512_mullo_epi32 保留乘法结果的低32位, _mm512_mulhi_epi32保存结果的高32位</span></span><br><span class="line">        <span class="comment">// m_c = _mm512_mullo_epi32(m_a, m_b);</span></span><br><span class="line">        _mm512_store_epi32(arr_c, m_c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;arr_a[%2d] is: %2d \t  arr_b[%2d] is: %2d \t  arr_c[%2d] is : %2d\n&quot;</span>, i, arr_a[i], i, arr_b[i], i, arr_c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    _mm_free(arr_a);</span><br><span class="line">    _mm_free(arr_b);</span><br><span class="line">    _mm_free(arr_c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    mic_add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">arr_a[ 0] is:  0 	  arr_b[ 0] is: 16 	  arr_c[ 0] is : 16</span><br><span class="line">arr_a[ 1] is:  1 	  arr_b[ 1] is: 17 	  arr_c[ 1] is : 18</span><br><span class="line">arr_a[ 2] is:  2 	  arr_b[ 2] is: 18 	  arr_c[ 2] is : 20</span><br><span class="line">arr_a[ 3] is:  3 	  arr_b[ 3] is: 19 	  arr_c[ 3] is : 22</span><br><span class="line">arr_a[ 4] is:  4 	  arr_b[ 4] is: 20 	  arr_c[ 4] is : 24</span><br><span class="line">arr_a[ 5] is:  5 	  arr_b[ 5] is: 21 	  arr_c[ 5] is : 26</span><br><span class="line">arr_a[ 6] is:  6 	  arr_b[ 6] is: 22 	  arr_c[ 6] is : 28</span><br><span class="line">arr_a[ 7] is:  7 	  arr_b[ 7] is: 23 	  arr_c[ 7] is : 30</span><br><span class="line">arr_a[ 8] is:  8 	  arr_b[ 8] is: 24 	  arr_c[ 8] is : 32</span><br><span class="line">arr_a[ 9] is:  9 	  arr_b[ 9] is: 25 	  arr_c[ 9] is : 34</span><br><span class="line">arr_a[10] is: 10 	  arr_b[10] is: 26 	  arr_c[10] is : 36</span><br><span class="line">arr_a[11] is: 11 	  arr_b[11] is: 27 	  arr_c[11] is : 38</span><br><span class="line">arr_a[12] is: 12 	  arr_b[12] is: 28 	  arr_c[12] is : 40</span><br><span class="line">arr_a[13] is: 13 	  arr_b[13] is: 29 	  arr_c[13] is : 42</span><br><span class="line">arr_a[14] is: 14 	  arr_b[14] is: 30 	  arr_c[14] is : 44</span><br><span class="line">arr_a[15] is: 15 	  arr_b[15] is: 31 	  arr_c[15] is : 46</span><br></pre></td></tr></table></figure><h3 id="With-Mask"><a href="#With-Mask" class="headerlink" title="With Mask"></a>With Mask</h3><p>MIC提供的向量函数一般有两种形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Without Mask</span></span><br><span class="line"><span class="keyword">extern</span> _m512i __cdecl _mm512_add_epi32(_m512i v2, _m512i v3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// With Mask</span></span><br><span class="line"><span class="keyword">extern</span> _m512i __cdecl _mm512_mask_add_epi32(_m512i v1_old, __mmask16 k1, _m512i v2, _m512i v3);</span><br></pre></td></tr></table></figure><p>一种是带Mask的, 一种是不带Mask的. 带Mask的多了两个参数: <code>v1_old</code>和<code>k1</code>, 其中<code>k1</code>是<code>__mmask16</code>类型的数据, 在上面我们知道<code>__mmask</code>类型就是<code>unsigned short</code>类型, 长度为16位. 关于带mask函数的解释: 将<code>v1</code>的16位分别对应到<code>_m512i</code>的16个整型上, 如果<code>k1</code>某个位是1, 则将v2和v3中与该位对应的整型相加, 作为结果值, 如果<code>k1</code>某个位为0, 就使用<code>v1_old</code>向量中对应位的整型作为结果值. 例如如果<code>k1</code>的第一位为1, 那么就将<code>v2</code>的第一个整数和<code>v3</code>的第一个整数相加, 作为结果向量的第一个整型的值. 如果<code>k1</code>的第一位是0, 就将<code>v1_old</code>向量中的第一个整型的值作为结果向量中第一个整型的值. 好吧, 还是看个例子吧.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mic_mask_add</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> *arr_a, *arr_b, *arr_c, *arr_old;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, n = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    arr_a = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line">    arr_b = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line">    arr_c = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line">    arr_old = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr_a[i] = i;</span><br><span class="line">        arr_b[i] = n + i; </span><br><span class="line">        arr_old[i] = <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> offload target(mic) in(arr_a:length(n)) in(arr_b:length(n)) in(arr_old:length(n)) out(arr_c:length(n))</span></span><br><span class="line">    &#123;</span><br><span class="line">        __m512i m_a, m_b, m_c, m_old;</span><br><span class="line">        <span class="comment">// 11换成二进制就是0000000000001011</span></span><br><span class="line">        __mmask16 k1 = <span class="number">11</span>;</span><br><span class="line">        m_a = _mm512_load_epi32(arr_a);</span><br><span class="line">        m_b = _mm512_load_epi32(arr_b);</span><br><span class="line">        m_old = _mm512_load_epi32(arr_old);</span><br><span class="line">        <span class="comment">// 根据k1的值只有1,2,4位为1 所以m_c中只有第1,2,4个元素为m_a 和m_b中1,2,4个元素的和 剩余元素使用arr_old对应元素的值</span></span><br><span class="line">        m_c = _mm512_mask_add_epi32(m_old, k1, m_a, m_b);</span><br><span class="line">        _mm512_store_epi32(arr_c, m_c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;arr_a[%2d] is: %2d \t  arr_b[%2d] is: %2d \t arr_old[%2d] is: %d \t  arr_c[%2d] is : %2d\n&quot;</span>, i, arr_a[i], i, arr_b[i], i, arr_old[i], i, arr_c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    _mm_free(arr_a);</span><br><span class="line">    _mm_free(arr_b);</span><br><span class="line">    _mm_free(arr_c);</span><br><span class="line">    _mm_free(arr_old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">arr_a[ 0] is:  0 	  arr_b[ 0] is: 16 	 arr_old[ 0] is: 10000 	  arr_c[ 0] is : 16</span><br><span class="line">arr_a[ 1] is:  1 	  arr_b[ 1] is: 17 	 arr_old[ 1] is: 10000 	  arr_c[ 1] is : 18</span><br><span class="line">arr_a[ 2] is:  2 	  arr_b[ 2] is: 18 	 arr_old[ 2] is: 10000 	  arr_c[ 2] is : 10000</span><br><span class="line">arr_a[ 3] is:  3 	  arr_b[ 3] is: 19 	 arr_old[ 3] is: 10000 	  arr_c[ 3] is : 22</span><br><span class="line">arr_a[ 4] is:  4 	  arr_b[ 4] is: 20 	 arr_old[ 4] is: 10000 	  arr_c[ 4] is : 10000</span><br><span class="line">arr_a[ 5] is:  5 	  arr_b[ 5] is: 21 	 arr_old[ 5] is: 10000 	  arr_c[ 5] is : 10000</span><br><span class="line">arr_a[ 6] is:  6 	  arr_b[ 6] is: 22 	 arr_old[ 6] is: 10000 	  arr_c[ 6] is : 10000</span><br><span class="line">arr_a[ 7] is:  7 	  arr_b[ 7] is: 23 	 arr_old[ 7] is: 10000 	  arr_c[ 7] is : 10000</span><br><span class="line">arr_a[ 8] is:  8 	  arr_b[ 8] is: 24 	 arr_old[ 8] is: 10000 	  arr_c[ 8] is : 10000</span><br><span class="line">arr_a[ 9] is:  9 	  arr_b[ 9] is: 25 	 arr_old[ 9] is: 10000 	  arr_c[ 9] is : 10000</span><br><span class="line">arr_a[10] is: 10 	  arr_b[10] is: 26 	 arr_old[10] is: 10000 	  arr_c[10] is : 10000</span><br><span class="line">arr_a[11] is: 11 	  arr_b[11] is: 27 	 arr_old[11] is: 10000 	  arr_c[11] is : 10000</span><br><span class="line">arr_a[12] is: 12 	  arr_b[12] is: 28 	 arr_old[12] is: 10000 	  arr_c[12] is : 10000</span><br><span class="line">arr_a[13] is: 13 	  arr_b[13] is: 29 	 arr_old[13] is: 10000 	  arr_c[13] is : 10000</span><br><span class="line">arr_a[14] is: 14 	  arr_b[14] is: 30 	 arr_old[14] is: 10000 	  arr_c[14] is : 10000</span><br><span class="line">arr_a[15] is: 15 	  arr_b[15] is: 31 	 arr_old[15] is: 10000 	  arr_c[15] is : 10000</span><br></pre></td></tr></table></figure><h3 id="Bitwise运算"><a href="#Bitwise运算" class="headerlink" title="Bitwise运算"></a>Bitwise运算</h3><p>MIC中提供了3中Bitwise运算函数- <code>and</code> <code>or</code> <code>xor</code>, 其中取反元素可以通过与1异或来实现, 下面是<code>and</code>操作的一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mic_and</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> *arr_a, *arr_b, *arr_c;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, n = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    arr_a = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line">    arr_b = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line">    arr_c = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr_a[i] = i ;</span><br><span class="line">        arr_b[i] = n + i; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> offload target(mic) in(arr_a:length(n)) in(arr_b:length(n)) out(arr_c:length(n))</span></span><br><span class="line">    &#123;</span><br><span class="line">        __m512i m_a, m_b, m_c;</span><br><span class="line">        m_a = _mm512_load_epi32(arr_a);</span><br><span class="line">        m_b = _mm512_load_epi32(arr_b);</span><br><span class="line">        m_c = _mm512_and_epi32(m_a, m_b);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// or</span></span><br><span class="line">        <span class="comment">// m_c = _mm512_or_epi32(m_a, m_b);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// xor</span></span><br><span class="line">        <span class="comment">// m_c = _mm512_xor_epi32(m_a, m_b);</span></span><br><span class="line">        _mm512_store_epi32(arr_c, m_c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        print_binary (arr_a[i], <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; &amp; &quot;</span>);</span><br><span class="line">        print_binary(arr_b[i], <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot; = &quot;</span>);</span><br><span class="line">        print_binary(arr_c[i], <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    _mm_free(arr_a);</span><br><span class="line">    _mm_free(arr_b);</span><br><span class="line">    _mm_free(arr_c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>print_binary</code>是一个打印二进制的函数, 这里只打印了后8位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印二进制</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">print_binary</span><span class="params">(<span class="type">uint64_t</span> t, <span class="type">int</span> bit_len)</span> &#123;</span><br><span class="line">	<span class="type">short</span> buffer[bit_len];</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; bit_len; i++) &#123;</span><br><span class="line">		buffer[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; bit_len; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (t == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (t % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			buffer[i] = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			buffer[i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		t = t / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = bit_len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%hd&quot;</span>, buffer[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个取反的示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mic_not</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> *arr_a, *arr_c;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, n = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    arr_a = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line">    arr_c = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr_a[i] = i ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> offload target(mic) in(arr_a:length(n)) out(arr_c:length(n))</span></span><br><span class="line">    &#123;</span><br><span class="line">        __m512i m_a, m_b, m_c;</span><br><span class="line">        <span class="type">int32_t</span> all_one = <span class="number">0xffffffff</span>;</span><br><span class="line">        <span class="comment">// _mm512_set1_epi32 : 将向量中的16个整型都设为all_one</span></span><br><span class="line">        m_b = _mm512_set1_epi32(all_one);</span><br><span class="line">        m_a = _mm512_load_epi32(arr_a);</span><br><span class="line">        m_c = _mm512_xor_epi32(m_a, m_b);</span><br><span class="line">        _mm512_store_epi32(arr_c, m_c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;~ &quot;</span>);</span><br><span class="line">        print_binary (arr_a[i], <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; = &quot;</span>);</span><br><span class="line">        print_binary(arr_c[i], <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    _mm_free(arr_a);</span><br><span class="line">    _mm_free(arr_c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是运行结果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">~ 00000000 = 11111111</span><br><span class="line">~ 00000001 = 11111110</span><br><span class="line">~ 00000010 = 11111101</span><br><span class="line">~ 00000011 = 11111100</span><br><span class="line">~ 00000100 = 11111011</span><br><span class="line">~ 00000101 = 11111010</span><br><span class="line">~ 00000110 = 11111001</span><br><span class="line">~ 00000111 = 11111000</span><br><span class="line">~ 00001000 = 11110111</span><br><span class="line">~ 00001001 = 11110110</span><br><span class="line">~ 00001010 = 11110101</span><br><span class="line">~ 00001011 = 11110100</span><br><span class="line">~ 00001100 = 11110011</span><br><span class="line">~ 00001101 = 11110010</span><br><span class="line">~ 00001110 = 11110001</span><br><span class="line">~ 00001111 = 11110000</span><br></pre></td></tr></table></figure><h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><p>移位操作分为算术移位和逻辑移位, 逻辑左移和算术左移的规则是一样的, 所以两者共用同一个左移函数, 而逻辑右移和算术右移不同, 逻辑右移是一直补0, 而算术右移要看符号位, 符号位为0则补0, 符号位为1, 则补1. 同时移位操作有两种形式, 一种给定一个常数, 向量中的每个元素都移该常数位, 一种是给定一个向量, 向量中的每个元素移给定向量中对应数值的位. 好吧下面还是看例子吧.<br><strong>左移: 给定一个常数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mic_lshift</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> *arr_a, *arr_c;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, n = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    arr_a = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line">    arr_c = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr_a[i] = i ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> offload target(mic) in(arr_a:length(n)) out(arr_c:length(n))</span></span><br><span class="line">    &#123;</span><br><span class="line">        __m512i m_a, m_c;</span><br><span class="line">        m_a = _mm512_load_epi32(arr_a);</span><br><span class="line">        <span class="comment">// 向量中的每个整型都左移一位 ,逻辑右移 _mm512_srli_epi32</span></span><br><span class="line">        m_c = _mm512_slli_epi32 (m_a, <span class="number">1</span>);</span><br><span class="line">        _mm512_store_epi32(arr_c, m_c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        print_binary (arr_a[i], <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; \t  &quot;</span>);</span><br><span class="line">        print_binary(arr_c[i], <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _mm_free(arr_a);</span><br><span class="line">    _mm_free(arr_c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>左移:给定一个向量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mic_lshift_v</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> *arr_a, *arr_c;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, n = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    arr_a = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line">    arr_c = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr_a[i] = i+<span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> offload target(mic) in(arr_a:length(n)) out(arr_c:length(n))</span></span><br><span class="line">    &#123;</span><br><span class="line">        __m512i m_a, m_b, m_c;</span><br><span class="line">        <span class="comment">// _mm512_set_epi32(int e15, int e14, int e13, int e12, int e11, int e10, int e9, int e8, int e7, int e6, int e5, int e4, int e3, int e2, int e1, int e0);</span></span><br><span class="line">        <span class="comment">// _mm512_set_epi32 按从高到低的顺序, 第一个参数设为向量中第16个整型的值, 最后一个参数设为第1个整型的值</span></span><br><span class="line">        m_b = _mm512_set_epi32(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        m_a = _mm512_load_epi32(arr_a);</span><br><span class="line">        <span class="comment">//  逻辑右移 _mm512_srlv_epi32</span></span><br><span class="line">        m_c = _mm512_sllv_epi32 (m_a, m_b);</span><br><span class="line">        _mm512_store_epi32(arr_c, m_c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        print_binary (arr_a[i], <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; \t  &quot;</span>);</span><br><span class="line">        print_binary(arr_c[i], <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    _mm_free(arr_a);</span><br><span class="line">    _mm_free(arr_c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00000001 	  00010000</span><br><span class="line">00000010 	  00010000</span><br><span class="line">00000011 	  00001100</span><br><span class="line">00000100 	  00001000</span><br><span class="line">00000101 	  01010000</span><br><span class="line">00000110 	  00110000</span><br><span class="line">00000111 	  00011100</span><br><span class="line">00001000 	  00010000</span><br><span class="line">00001001 	  10010000</span><br><span class="line">00001010 	  01010000</span><br><span class="line">00001011 	  00101100</span><br><span class="line">00001100 	  00011000</span><br><span class="line">00001101 	  11010000</span><br><span class="line">00001110 	  01110000</span><br><span class="line">00001111 	  00111100</span><br><span class="line">00010000 	  00100000</span><br></pre></td></tr></table></figure><p><strong>算术右移</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mic_arshift</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> *arr_a, *arr_b, *arr_c, *arr_d;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, n = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    arr_a = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line">    arr_b = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line">    arr_c = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line">    arr_d = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> high_one = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr_a[i] = i+<span class="number">1</span>;</span><br><span class="line">        arr_b[i] = high_one | (i + <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> offload target(mic) in(arr_a:length(n)) in(arr_b:length(n)) out(arr_c:length(n)) out(arr_d:length(n))</span></span><br><span class="line">    &#123;</span><br><span class="line">        __m512i m_a,m_b, m_c, m_d;</span><br><span class="line">        m_a = _mm512_load_epi32(arr_a);</span><br><span class="line">        <span class="comment">//  算术右移, 符号为0, 补0；符号位为1, 补1</span></span><br><span class="line">        m_c = _mm512_srai_epi32 (m_a, <span class="number">2</span>);</span><br><span class="line">        _mm512_store_epi32(arr_c, m_c);</span><br><span class="line">        m_b = _mm512_load_epi32(arr_b);</span><br><span class="line">        m_d = _mm512_srai_epi32(m_b, <span class="number">2</span>);</span><br><span class="line">        _mm512_store_epi32(arr_d, m_d);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;符号位为0: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        print_binary (arr_a[i],<span class="number">32</span>);</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; \t  &quot;</span>);</span><br><span class="line">        print_binary(arr_c[i], <span class="number">32</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;符号位为1: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        print_binary (arr_b[i],<span class="number">32</span>);</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; \t  &quot;</span>);</span><br><span class="line">        print_binary(arr_d[i], <span class="number">32</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _mm_free(arr_a);</span><br><span class="line">    _mm_free(arr_b);</span><br><span class="line">    _mm_free(arr_c);</span><br><span class="line">    _mm_free(arr_d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">符号位为0: </span><br><span class="line">00000000000000000000000000000001 	  00000000000000000000000000000000</span><br><span class="line">00000000000000000000000000000010 	  00000000000000000000000000000000</span><br><span class="line">00000000000000000000000000000011 	  00000000000000000000000000000000</span><br><span class="line">00000000000000000000000000000100 	  00000000000000000000000000000001</span><br><span class="line">00000000000000000000000000000101 	  00000000000000000000000000000001</span><br><span class="line">00000000000000000000000000000110 	  00000000000000000000000000000001</span><br><span class="line">00000000000000000000000000000111 	  00000000000000000000000000000001</span><br><span class="line">00000000000000000000000000001000 	  00000000000000000000000000000010</span><br><span class="line">00000000000000000000000000001001 	  00000000000000000000000000000010</span><br><span class="line">00000000000000000000000000001010 	  00000000000000000000000000000010</span><br><span class="line">00000000000000000000000000001011 	  00000000000000000000000000000010</span><br><span class="line">00000000000000000000000000001100 	  00000000000000000000000000000011</span><br><span class="line">00000000000000000000000000001101 	  00000000000000000000000000000011</span><br><span class="line">00000000000000000000000000001110 	  00000000000000000000000000000011</span><br><span class="line">00000000000000000000000000001111 	  00000000000000000000000000000011</span><br><span class="line">00000000000000000000000000010000 	  00000000000000000000000000000100</span><br><span class="line">符号位为1: </span><br><span class="line">10000000000000000000000000000001 	  11100000000000000000000000000000</span><br><span class="line">10000000000000000000000000000010 	  11100000000000000000000000000000</span><br><span class="line">10000000000000000000000000000011 	  11100000000000000000000000000000</span><br><span class="line">10000000000000000000000000000100 	  11100000000000000000000000000001</span><br><span class="line">10000000000000000000000000000101 	  11100000000000000000000000000001</span><br><span class="line">10000000000000000000000000000110 	  11100000000000000000000000000001</span><br><span class="line">10000000000000000000000000000111 	  11100000000000000000000000000001</span><br><span class="line">10000000000000000000000000001000 	  11100000000000000000000000000010</span><br><span class="line">10000000000000000000000000001001 	  11100000000000000000000000000010</span><br><span class="line">10000000000000000000000000001010 	  11100000000000000000000000000010</span><br><span class="line">10000000000000000000000000001011 	  11100000000000000000000000000010</span><br><span class="line">10000000000000000000000000001100 	  11100000000000000000000000000011</span><br><span class="line">10000000000000000000000000001101 	  11100000000000000000000000000011</span><br><span class="line">10000000000000000000000000001110 	  11100000000000000000000000000011</span><br><span class="line">10000000000000000000000000001111 	  11100000000000000000000000000011</span><br><span class="line">10000000000000000000000000010000 	  11100000000000000000000000000100</span><br></pre></td></tr></table></figure><h3 id="mm512-alignr-epi32"><a href="#mm512-alignr-epi32" class="headerlink" title="_mm512_alignr_epi32"></a>_mm512_alignr_epi32</h3><p>函数原型为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> __m512i __cdecl _mm512_alignr_epi32(__m512i v2, __m512i v3, <span class="type">const</span> <span class="type">int</span> count);</span><br></pre></td></tr></table></figure><p>该函数的作用就是将v2和v3拼接起来, v2在前, v3在后, 然后循环左移count个元素, 然后取最右侧的16个元素, 下面看个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mic_alignr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> *arr_a, *arr_b, *arr_c, *arr_d;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, n = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    arr_a = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line">    arr_b = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line">    arr_c = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line">    arr_d = _mm_malloc(<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) * n, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr_a[i] = i+<span class="number">1</span>;</span><br><span class="line">        arr_b[i] = n + i + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> offload target(mic) in(arr_a:length(n)) in(arr_b:length(n)) out(arr_c:length(n)) out(arr_d:length(n))</span></span><br><span class="line">    &#123;</span><br><span class="line">        __m512i m_a,m_b, m_c, m_d;</span><br><span class="line">        m_a = _mm512_load_epi32(arr_a);</span><br><span class="line">        m_b = _mm512_load_epi32(arr_b);</span><br><span class="line">        <span class="comment">//  算术右移, 符号为0, 补0；符号位为1, 补1</span></span><br><span class="line">        m_c = _mm512_alignr_epi32 (m_a, m_b, <span class="number">3</span>);</span><br><span class="line">        _mm512_store_epi32(arr_c, m_c);</span><br><span class="line">        m_d = _mm512_alignr_epi32(m_a, m_b, <span class="number">8</span>);</span><br><span class="line">        _mm512_store_epi32(arr_d, m_d);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr_a: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%2u &quot;</span>, arr_a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; \narr_b: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%2u &quot;</span>, arr_b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;count = 3  arr_c: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%2u &quot;</span>, arr_c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;count = 8  arr_c: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%2u &quot;</span>, arr_d[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    _mm_free(arr_a);</span><br><span class="line">    _mm_free(arr_b);</span><br><span class="line">    _mm_free(arr_c);</span><br><span class="line">    _mm_free(arr_d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr_a:  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16  </span><br><span class="line">arr_b: 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 </span><br><span class="line"></span><br><span class="line">count = 3  arr_c: 20 21 22 23 24 25 26 27 28 29 30 31 32  1  2  3 </span><br><span class="line">count = 8  arr_c: 25 26 27 28 29 30 31 32  1  2  3  4  5  6  7  8 </span><br></pre></td></tr></table></figure></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul class="copyright-info-content"><li class="post-title"><span class="type">本文标题</span>：<span class="content">【MIC学习笔记】向量化</span></li><li class="post-author"><span class="type">本文作者</span>：<span class="content">Pin Young</span></li><li class="post-time"><span class="type">创建时间</span>：<span class="content">2015-12-27 16:58:31</span></li><li class="post-link"><span class="type">本文链接</span>：<span class="content">posts/eab1.html</span></li><li class="post-license"><span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span></li></ul><div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px"><i class="fa-solid fa-copy"></i></div></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">#学习笔记</a>&nbsp;</li><li class="tag-item"><a href="/tags/MIC/">#MIC</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/posts/5c06.html"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">mysql 导入导出数据</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/posts/cdbc.html"><span class="title flex-center"><span class="post-nav-title-item">【软件】Intellij IDEA 导入maven web项目并部署到Tomcat</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E5%8C%96%E5%87%BD%E6%95%B0-Intrinsics"><span class="nav-number">3.</span> <span class="nav-text">向量化函数(Intrinsics)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="nav-number">3.1.</span> <span class="nav-text">算术运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#With-Mask"><span class="nav-number">3.2.</span> <span class="nav-text">With Mask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bitwise%E8%BF%90%E7%AE%97"><span class="nav-number">3.3.</span> <span class="nav-text">Bitwise运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="nav-number">3.4.</span> <span class="nav-text">移位操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mm512-alignr-epi32"><span class="nav-number">3.5.</span> <span class="nav-text">_mm512_alignr_epi32</span></a></li></ol></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2014</span> - 2023 &nbsp;<i class="fas fa-heart icon-animate"></i> &nbsp;<a href="/">Pin Young</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; 总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></div><div class="theme-info info-item">由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/dstansice">零域Lite 1.1</a></div><script async defer data-website-id="b3b1feba-ef0f-4367-ba34-6a0152b8749b" src="https://analysis.0skyu.cn/umami.js"></script><div class="icp-info info-item"><div class="theme-info info-item"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12011002021027" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src="https://0skyu.cn/beian.png" style="float:left"><p style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">津公网安备 12011002021027号</p></a></div><div class="theme-info info-item"><center><a target="_blank" rel="nofollow" href="https://beian.miit.gov.cn">津ICP备2021004482号-1</a></center></div></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-top flex-center"><i class="fas fa-arrow-up"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/dark-light-toggle.js"></script><script src="/js/local-search.js"></script><script src="/js/code-block.js"></script><script src="/js/lazyload.js"></script><div class="post-scripts pjax"><script src="/js/post-helper.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/toc.js"></script></div><script src="/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script></body></html>