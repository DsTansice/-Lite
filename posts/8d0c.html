<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="空中有零，零域，分享快乐，音乐，心得，生活，电影，代码，编程，考试，学业，零式的天空，凌空博客，原零空博客，原Tans博客，现零的小屋官方博客，计算机，音乐，电脑，编程，生活，分享">
    <meta name="description" content="一个技术控，爱技术，爱分享，爱音乐">
    <meta name="author" content="Pin Young">
    
    <title>
        
            【Java 并发】详解 ThreadPoolExecutor |
        
        零域
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/img/favicon.png">
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"0skyu.cn","root":"/","language":"zh-CN","path":"search.xml"}
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#EE5A24","logo":"/img/favicon.png","favicon":"/img/favicon.png","avatar":"img/1.jpg","font_size":null,"font_family":null,"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"header_transparent":false,"background_img":"/img/bg/333.jpg","description":"Keep writing and Keep loving.","font_color":"#f0d21a","hitokoto":true},"scroll":{"progress_bar":true,"percent":false}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":false,"use":"gitalk","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":"DsTansice","github_admins":"DsTansice","repository":"Null-Comment","client_id":"b109b534b2268088d780","client_secret":"7808e138a1ffbcd9f02bb39cc1ee7fb41828c52f","proxy":null},"twikoo":{"env_id":"twikoo-0skyucn-1gkzaji32bb03146","region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":true},"img_align":"left","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="零域" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/img/favicon.png">
                </a>
            
            <a class="logo-title" href="/">
               零域
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                友链
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               target="_blank" rel="noopener" href="https://hao.0skyu.cn/"
                            >
                                HAO
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">友链</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       target="_blank" rel="noopener" href="https://hao.0skyu.cn/">HAO</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">【Java 并发】详解 ThreadPoolExecutor</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/img/1.jpg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">Pin Young</span>
                            
                                <span class="author-label">Lv9</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2017-04-22 20:39:28</span>
        <span class="mobile">2017-04-22 20:39</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2023-02-02 13:39:48</span>
    </span>
    
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Java-%E5%B9%B6%E5%8F%91/">Java 并发</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Java/">Java</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/%E5%B9%B6%E5%8F%91/">并发</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>7.9k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>31 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>线程池是并发中一项常用的优化方法，通过对线程复用，减少线程的创建，降低资源消耗，提高程序响应速度。在 Java 中我们一般通过 Exectuors 提供的工厂方法来创建线程池，但是线程池的最终实现类是 ThreadPoolExecutor，下面我们详细分析一下 ThreadPoolExecutor 的实现。</p>
<span id="more"></span>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>我们首先看下线程池的基本使用。在下面的代码中我们创建一个固定大小的线程池，该线程池中最多包含 5 个线程，当任务数量超过线程的数量时，就将任务添加到任务队列，等线程空闲之后再从任务队列中获取任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Jikai Zhang on 2017/4/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WorkThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">WorkThread</span><span class="params">(String command)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.command = command;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread-&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; start. Command=&quot;</span> + command);</span><br><span class="line">            processCommand();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread-&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; end.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCommand</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">work</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkThread</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            executor.execute(work);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finish all threads.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在分析线程池的具体实现之前，我们首先看下线程池具体的工作流程，只有先熟悉了流程，才能更好的理解线程池的实现。线程池一般都会关联一个任务队列，用来缓存任务，当线程执行完一个任务之后，会从任务队列中取下一个任务。ThreadPoolExecutor 中使用阻塞队列作为任务队列，当任务队列为空时，就会阻塞请求任务的线程。下面是 ThreadPoolExecutor 整体的图示：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/threadpool/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png"
                     
                ></p>
<blockquote>
<p>图片来自 Java 并发编程的艺术</p>
</blockquote>
<p>下面我们着重看下 ThreadPoolExecutor 添加任务和关闭线程池的流程。下图是 ThreadPoolExecutor 添加任务的流程：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/threadpool/%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1.png"
                     
                ></p>
<p>我们首先看下添加任务的具体流程：</p>
<ul>
<li>如果线程池中的线程数量少于 corePoolSize，那么直接创建一个新的线程（不论线程池中是否有空闲线程），然后把该任务分配给新建线程，同时将线程加入到线程池中。</li>
<li>如果线程池的线程数量大于等于 corePoolSize，就将任务添加到任务队列</li>
<li>如果任务队列已经饱和（对于有边界的任务队列），那么就看下线程池中的线程数量是否少于 maximumPoolSize，如果少于，就创建新的线程，将当前任务分配给新线程，同时将线程加入到线程池中。否则就对该任务执行 reject 策略。</li>
</ul>
<p>在 ThreadPoolExecutor 中通过两个量来控制线程池的大小：corePoolSize 和 maximumPoolSize。corePoolSize 表示正常状态下线程池中应该持有的存活线程数量，maximumPoolSize 表示线程池可以持有的最大线程数量。当线程池中的线程数量不超过 corePoolSize 时，位于线程池中的线程被看作 core 线程，默认情况下，线程池不对 core 线程进行超时控制，也就是 core 线程会一直存活在线程池中，直到线程池被关闭（这里忽略线程异常关闭的情况）。当线程池中的线程数量超过 corePoolSize 时，额外的线程被看作非 core 线程，线程池会对这部分线程进行超时控制，当线程空闲一段时间之后会销毁该线程。非 core 线程主要用来处理某段时间并发任务特别多的情况，即之前的线程配置无法及时处理那么多的任务量，需要额外的线程来帮助。而当这批任务处理完成之后，额外的线程就有些多余了（线程越多占的资源越多），因此需要及时销毁。</p>
<p>ThreadPoolExecutor 定义线程数量上限是 <code>2^29 - 1 = 536870911</code>（后面会讲到为什么是这个数），同时用户可以自定义最大线程数量，ThreadPoolExecutor 处理时会选两者之间的较小值。当线程池的线程数量等于 maximumPoolSize 时，说明线程池也已经饱和了，此时对于新来的任务就要执行 reject 策略，JDK 中定义了四种拒绝策略：</p>
<ul>
<li>AbortPolicy：直接抛出异常，默认策略</li>
<li>CallerRunsPolicy：使用调用者所在的线程执行任务</li>
<li>DiscardOldestPolicy：丢弃当前任务队列中最前面的任务，并执行 execute 方法添加新任务</li>
<li>DiscardPolicy：直接丢弃任务</li>
</ul>
<p>下面再看一下线程池的关闭。线程池的关闭分为两种：平缓关闭（shutdown）和立即关闭（shutdownNow）。当调用 shutdown 方法之后，线程池不再接受新的任务，但是仍然会将任务队列中已有的任务执行完毕。而调用 shutdownNow 方法之后，线程池不仅不再接受新的任务，也不会再执行任务队列中剩余的任务，同时会通过中断的方式尝试停止正在执行任务的线程（我们知道对于中断，线程可能响应也可能不响应，所以不能保证一定停止线程）。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>下面我们从源码的角度分析一下 ThreadPoolExecutor 的实现。</p>
<h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p>ThreadPoolExecutor 中每个线程都关联一个 Worker 对象，而 ThreadPool 里实际上保存的就是线程关联的 Worker 对象。 Worker 类对线程进行包装，它除了保存关联线程的信息，还保存一些其他的信息，如线程创建时分配的首任务，线程已完成的任务数量。Worker 实现了 Runnable 接口，创建线程时往 Thread 类传的参数就是该对象，所以线程创建后会执行 Worker 的 run 方法。同时 Worker 类还继承了 AbstractQueuedSynchronizer，使自身成为一个不可重入的互斥锁（以下称为 Worker 锁，注意 Worker 锁是不可重入的，也就是说该锁只能被一个线程获取一次），因此每个线程实际上也关联了一个互斥锁。当线程执行任务时，需要首先获得关联的 Worker 锁，执行完任务之后再释放该锁。Worker 锁的主要作用是为了平缓关闭线程池时，判断线程是否空闲（根据能否获得 Worker 锁），后续会详细讲解。下面是 Worker 类的实现，我们只保留了一些必要的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 Worker 对象关联的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">// 线程创建后的初始任务</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">// 线程完成的任务数量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">// 只有 state 为 0，线程才能获取到 Worker 锁，这里将 state 设为 -1，</span></span><br><span class="line">        <span class="comment">// 表明任何线程都无法获取锁，在 shutdown 方法中，如果要中断线程，需要首先获得线程</span></span><br><span class="line">        <span class="comment">// 关联的 Worker 锁，而 shutdownNow 中断线程之前，会首先判断 state 是否大于等于 0</span></span><br><span class="line">        <span class="comment">// 所以这里将 state 设为 -1，可以防止当前线程被中断</span></span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 创建线程时将自身传入</span></span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="comment">// 线程创建之后会运行该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        runWorker(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要线程启动了，就中断线程，用于 shutdownNow 方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">interruptIfStarted</span><span class="params">()</span> &#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到在 Worker 的构造函数中将 state 设为了 -1，注释里给出的解释是：禁止中断直到执行了 runWorker 方法。其实这里包含了两个问题：1.为什么要等到执行了 runWorker 方法 2.怎样禁止中断。对于第一个问题，我们知道中断是针对运行的线程，当线程创建之后只有调用了 start 方法，线程才真正运行，而 start 方法的调用是在 runWorker 方法中的，也就是有只有执行了 runWorker 方法，线程才真正启动。对于第二个问题，这个主要是针对 shutdown 和 shutdownNow 方法的。在 shutdown 方法中，中断线程之前会首先尝试获取线程的 Worker 锁，只有获得了 Worker 锁才对线程进行中断。而获得 Worker 锁的前提是 Worker 的锁的状态变量 state 为 0，当 state 设为 -1 之后，任何线程都无法获得该锁，那么也就无法对线程执行中断操作。而在 shutdownNow 方法中，会调用 Worker 的 interruptIfStarted 方法来中断线程，而 interruptIfStarted 方法只有在 state &gt;&#x3D; 0 时才会中断线程，所以将 state 设为 -1 可以防止线程被提前中断。当执行 runWorker 方法时，会为传入 Worker 对象执行 unlock 操作（也就是将 state 加 1），使 Worker 对象的 state 变为 0，这样就使线程处于可被中断的状态了。</p>
<h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><p>在 ThreadPoolExecutor 中定义了一个 AtomicInteger 类型的变量 ctl，用来保存线程池的状态和线程数量信息。下面是该变量的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>ctl 使用低 29 位保存线程的数量（这就是线程池最大线程数量为 <code>2^29-1</code> 的原因），高 3 位保存线程池的状态。为了提取出这两个信息，ThreadPoolExecutor 定义了一个低 29 位全为 1 的变量 CAPACITY，通过和 CAPACITY 进行 &amp; 运算可以获得线程的数量，通过和 ~CAPACITY 进行 &amp; 运算可以获得线程池的状态，下面是程序中的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储线程数量的 bit 位数，这里是 29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于提取线程池的运行状态以及线程数量，低 29 位全为 1，高 3 位为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得线程池的运行状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; ~CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得线程的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadPoolExecutor 中为线程池定义了五种状态：</p>
<ul>
<li>RUNNING：正常状态，接受新的任务，并处理任务队列中的任务</li>
<li>SHUTDOWN：不接受新的任务，但是处理已经在任务队列中的任务</li>
<li>STOP： 不接受新的任务，也不处理已经在任务队列中的任务，同时会尝试停止正在执行任务的线程</li>
<li>TIDYING： 线程池和任务队列都为空，该状态下线程会执行 terminated() 方法</li>
<li>TERMINATED：terminated() 方法执行完毕</li>
</ul>
<p>下面是 JDK 中关于这 5 个变量的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 11100000000000000000000000000000  -536870912</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span> <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 00000000000000000000000000000000  0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span> <span class="operator">=</span> <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 00100000000000000000000000000000  536870912</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 01000000000000000000000000000000  1073741824</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span> <span class="operator">=</span> <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 01100000000000000000000000000000  1610612736</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span> <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>
<p>下面是各状态之间的转换：</p>
<ul>
<li>RUNNING -&gt; SHUTDOWN：调用了 shutdown() 方法 （perhaps implicitly in finalize()）</li>
<li>(RUNNING or SHUTDOWN) -&gt; STOP：调用了shutdownNow() 方法</li>
<li>SHUTDOWN -&gt; TIDYING：线程池和任务队列都为空</li>
<li>STOP -&gt; TIDYING：线程池为空</li>
<li>TIDYING -&gt; TERMINATED：执行完 terminated() 方法</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/threadpool/%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png"
                     
                ></p>
<h3 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h3><p>通过 execute 或者 submit 方法都可以向线程池中添加一个任务，submit 会返回一个 Future 对象来获取线程的返回值，下面是 submit 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future &lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture &lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到 submit 中只是将 Runnable 对象包装了一下，最终还是调用了 execute 方法。下面我们看下 execute 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="comment">// command 不能为 null</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 线程数量少于 corePoolSize，会创建一个新的线程执行该任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// true 表示当前添加的线程为核心线程</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程数量大于等于 corePoolSize，首先尝试将任务添加到任务队列</span></span><br><span class="line">    <span class="comment">// workQueue.offer 会将任务添加到队列尾部</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 重新检查状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 如果发现当前线程池不是处于 Running 状态，就移除之前的任务</span></span><br><span class="line">        <span class="comment">// 移除任务过程有锁保护</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command)) &#123;</span><br><span class="line">            reject(command);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// workerCountOf 用来统计当前的工作线程数量，程序执行到这里，有下面两种可能：</span></span><br><span class="line">            <span class="comment">//  1. 当前线程池处于 Running 状态，但是工作线程数量为 0，</span></span><br><span class="line">            <span class="comment">//      需要创建新的线程</span></span><br><span class="line">            <span class="comment">//  2. 移除任务失败，但是工作线程数量为 0，</span></span><br><span class="line">            <span class="comment">//      需要创建新的线程来完成移除失败的任务</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">//  因为前面对任务做了判断，所以正常情况下向 addWorker 里传入的任务</span></span><br><span class="line">            <span class="comment">//  不可能为 null，这里传入 null 是告诉 addWorker 需要创建新的线程，</span></span><br><span class="line">            <span class="comment">//  在 addWorker 里对 null 有专门的处理逻辑</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 下面的 else 说明线程池不是 Running 状态或者任务队列满了，</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// 这里说明线程池不是 Running 状态或者线程池饱和了</span></span><br><span class="line">        reject(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面我们提到了线程池添加任务的流程，这里再重述一下</p>
<ul>
<li>如果线程池的线程数量少于 corePoolSize，则新建一个线程，执行当前任务，并将该任务加入到线程池</li>
<li>如果线程池中的线程数量大于等于 corePoolSize，则首先将任务添加到任务队列</li>
<li>如果任务队列已满，则继续创建线程，如果线程池达到了饱和值 maximumPoolSize，则调用 reject 策略处理该任务。</li>
</ul>
<p>addWorker 方法会创建并启动线程，当线程池不处于 Running 状态并且传入的任务不为 null，addWorker 就无法成功创建线程。下面看下它的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    <span class="comment">// retry 类似于 goto，continue retry 跳转到 retry 定义，</span></span><br><span class="line">    <span class="comment">// 而 break retry 跳出 retry</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们在下面详细讲解该条件</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="comment">// 线程数量大于系统规定的最大线程数或者大于 corePoolSize/maximumPoolSize</span></span><br><span class="line">            <span class="comment">// 表明线程池中无法添加新的线程，这里 wc &gt;= CAPACITY 为了防止 corePoolSize</span></span><br><span class="line">            <span class="comment">// 或者 maximumPoolSize 大于CAPACITY</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用 CAS 方式将线程数量增加，如果成功就跳出 retry</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c)) &#123;</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            c = ctl.get(); <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 如果线程池运行状态发生了改变就从 retry（外层循环）处重新开始，</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 程序执行到这里说 CAS 没有成功，那么就再次执行 CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 work</span></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="comment">// t != null 说明线程创建成功了</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 程序用一个 HashSet 存储线程，而 HashSet 不是线程的安全的，</span></span><br><span class="line">            <span class="comment">// 所以将线程加入 HashSet 的过程需要加锁。</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1. rs &lt; SHUTDOWN 说明程序在运行状态</span></span><br><span class="line">                <span class="comment">// 2. rs == SHUTDOWN  说明当前线程处于平缓关闭状态，而 firstTask == null</span></span><br><span class="line">                <span class="comment">//    说明当前创建的线程是为了处理任务队列中剩余的任务（故意传入 null）</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 线程是存活状态说明线程提前开始了。</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们着重看下返回 false 的条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">if</span>(rs &gt;= SHUTDOWN &amp;&amp; (rs != SHUTDOWN || firstTask != <span class="literal">null</span> || workQueue.isEmpty()))</span><br></pre></td></tr></table></figure>
<p>我们依次看下上面的条件：</p>
<ul>
<li>rs &gt;&#x3D; SHUTDOWN &amp;&amp; rs !&#x3D; SHUTDOWN：说明线程池处于 STOP，TIDYING 或者 TERMINATED 状态下，处于这三种状态说明线程池处理完了所有任务或者不再执行剩余的任务，可以直接返回</li>
<li>rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask !&#x3D; null：如果上面的条件不成立，说明当前线程池的状态一定是处于 SHUTDOWN 状态，在 execute 方法中，我们提到了如果传入 null，说明创建线程是为了执行队列中剩余的任务（此时线程池中没有工作线程），这时就不应该返回。而如果 firstTask !&#x3D; null，说明不是为了处理队列中剩余的任务，可以返回。</li>
<li>rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; workQueue.isEmpty()：说经任务队列中的任务已经全部执行完了，无需创建新的线程，可以返回。</li>
</ul>
<p>当创建了线程并成功启动之后，会执行 Worker 的 run 方法，而该方法最终调用了 ThreadPoolExecutor 的 runWorker 方法，并且将自身作为参数传进去了，下面是 runWorker 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 这里将 Worker 中的 state 设为 0，以便其他线程可以获得锁</span></span><br><span class="line">    <span class="comment">// 从而可以中断当前线程</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 用来标记线程是正常退出循环还是异常退出</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果任务不为空，说明是刚创建线程，如果任务为空，则从队列中取任务</span></span><br><span class="line">        <span class="comment">// 如果队列没有任务，线程就会阻塞在这里</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 任务执行之前做一些处理，空函数，需要用户定义处理逻辑</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x;</span><br><span class="line">                    <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x;</span><br><span class="line">                    <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x;</span><br><span class="line">                    <span class="comment">// 因为 runnable 方法不能抛出 checkedException ，所以这里</span></span><br><span class="line">                    <span class="comment">// 将异常包装成 Error 抛出</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 任务执行完之后做一些处理，默认空函数</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，第一个 if 判断的逻辑有点难理解，我们将它拿出分析一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateAtLeast</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP)))</span><br><span class="line">    &amp;&amp; !wt.isInterrupted())</span><br><span class="line">    wt.interrupt();</span><br></pre></td></tr></table></figure>
<p>这段 if 代码块的功能有两个：</p>
<ul>
<li>如果当前线程池的状态小于 STOP，也就是处于 RUNNING 或者 SHUTDOWN 状态，要保证线程池中的线程处于非中断状态</li>
<li>如果当前线程池的状态大于等于 STOP，也就是处于 STOP，TIDYING 或者 TERMINATED 状态，要保证线程池中的线程处于中断状态</li>
</ul>
<p>上面的 if 代码中括号比较多，我们先将其分为两个大条件：</p>
<ul>
<li>runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP)) &amp;&amp;</li>
<li>!wt.isInterrupted()</li>
</ul>
<p>我们先看第二个条件：!wt.isInterrupted()，该条件说明当前线程没有被中断，只有在线程没有被中断的前提下，才有可能对线程执行中断操作。然后我们将第一个大条件再进行拆分，可以分为下面两个条件：</p>
<ul>
<li>runStateAtLeast(ctl.get(), STOP) ||</li>
<li>Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP)</li>
</ul>
<p>我们先看第一个条件，该条件说明线程处于 STOP 以及之后的状态，线程应该被中断。如果该条件不成立，说明当前线程不应该被中断，那么会调用 Thread.interrupted() 方法，该方法会首返回线程的中断状态，然后重置线程中断状态（设为 false），如果中断状态本来就为 false，那么就可以就可以跳出 if 代码块了，但是如果中断状态是 true，说明线程被中断过了，此时我们就要判断线程的中断是不是由 shutdownNow 方法（并发调用，该方法会中断线程池的线程，并修改线程池状态为 STOP，后面会讲到）造成的，所以我们需要再检查一下线程的状态，如果发现当前线程池已经变为 STOP 或者之后的状态，说明确实是由 shutdownNow 方法造成的，需要重新对线程进行中断，如果不是那就不需要再中断线程了。</p>
<p>我们看到在 runWorker 里会一直循环调用 getTask 来获取任务，下面来看下 getTask 的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * getTask 返回 null，说明当前线程需要被回收了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// rs &gt;= SHUTDOWN 说明当前线程池至少处于待关闭状态，不再接受新的任务</span></span><br><span class="line">        <span class="comment">//  1. rs &gt;= STOP： 说明不需要在再处理任务了（即便有任务）</span></span><br><span class="line">        <span class="comment">//  2. workQueue.isEmpty(): 说明任务队列中剩余的任务已经处理完了</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// timed 用于判断是否需要对线程进行超时控制</span></span><br><span class="line">        <span class="comment">//  1. allowCoreThreadTimeOut: 为 true 说明可以对 core 线程进行超时控制</span></span><br><span class="line">        <span class="comment">//  2. wc &gt; corePoolSize: 说明线程池中有非 core 线程</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)</span></span><br><span class="line">        <span class="comment">//     线程数量大于 maximumPoolSize 值了 或者 允许超时控制并且超时了</span></span><br><span class="line">        <span class="comment">// 2. wc &gt; 1 || workQueue.isEmpty()</span></span><br><span class="line">        <span class="comment">//     线程中活动线程的数量大于 1 或者 任务队列为空（不需要在留线程执行剩余的任务了）</span></span><br><span class="line">        <span class="comment">// 如果上面 1 和 2 都成立，就使用 CAS 将线程数量减 1 并返回 null 回收当前线程</span></span><br><span class="line">        <span class="comment">// 如果 CAS 失败了就重试</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果允许超时控制，则执行 poll 方法，该方法响应超时，当 keepAliveTime 时间内</span></span><br><span class="line">            <span class="comment">// 仍然没有获取到任务，就返回 null。take 方法不响应超时操作，当获取不到任务时会一直等待。</span></span><br><span class="line">            <span class="comment">// 另外不管 poll 还是 take 方法都会响应中断，如果没有新的任务添加到队列中</span></span><br><span class="line">            <span class="comment">// 会直接抛出 InterruptedException</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 执行到这里说明超时了</span></span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 getTask 返回 null 的时候说明线程需要被回收了，我们总结一下在 getTask 中返回 null 的情况：</p>
<ul>
<li>线程池总工作线程数量大于 maximumPoolSize（一般是由于我们调用 setMaximumPoolSize 方法重新设置了 maximumPoolSize）</li>
<li>线程池已经被停止 （状态 &gt;&#x3D; STOP）</li>
<li>线程池处于 SHUTDOWN 状态，并且任务队列为空</li>
<li>线程在等待任务时超时</li>
</ul>
<p>我们将 runWorker 和 getTask 结合起来看，整个流程就比较明朗了：</p>
<ol>
<li>通过 while 循环不断的从任务队列中获取任务，如果当前任务队列中没有任务，就阻塞线程。如果 getTask 返回 null，表明当前线程应该被回收，执行回收线程的逻辑。</li>
<li>如果成功获取任务，首先判断线程池的状态，根据线程池状态设置当前线程的中断状态</li>
<li>在执行任务之前做一些预处理（用户实现）</li>
<li>执行任务</li>
<li>在执行任务之后做一些后处理（用户实现）</li>
</ol>
<p>上面两个方法是整个线程池中比较核心的部分，在这两个方法中，完成了任务获取与阻塞线程的工作。下面是线程 <code>提交 -&gt; 处理任务 -&gt; 回收</code> 的流程图：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/threadpool/%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B.png"
                     
                ></p>
<p>下面我们再看下 processWorkerExit 方法，该方法主要用来完成线程的回收工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 completedAbruptly 为 true，说明线程是由于抛出异常而跳出循环的，</span></span><br><span class="line">    <span class="comment">// 没有正确执行 getTask 中减少线程数量的逻辑，所以这里要将线程数量减一</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 更新已完成的任务数量，并移除工作线程</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试终止线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果线程状态是 SHUTDOWN 或者 RUNNING，需要保证线程中的最少线程数量</span></span><br><span class="line">    <span class="comment">// 1. 如果线程是由于抛出异常而结束的，直接添加一个线程</span></span><br><span class="line">    <span class="comment">// 2. 如果线程是正常结束的</span></span><br><span class="line">    <span class="comment">//    * 如果允许对 core 线程进行超时控制，并且任务队列中有任务</span></span><br><span class="line">    <span class="comment">//      则保证线程数量大于等于 1</span></span><br><span class="line">    <span class="comment">//    * 如果不允许对 core 进行超时控制，则保证线程数量大于等于 corePoolSize</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; !workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到 processWorkerExit 中调用了 tryTerminate 方法，该方法主要用来终止线程池。如果线程池满足终止条件，首先将线程池状态设为 TIDYING，然后执行 terminated 方法，最后将线程池状态设为 TERMINATED。在 shutdown 和 shutdownNow 方法中也会调用该方法 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 如果出现下面三种情况，就不执行终止线程池的逻辑，直接返回</span></span><br><span class="line">        <span class="comment">//  1. 当前线程池处于 RUNNING 状态，不能停止</span></span><br><span class="line">        <span class="comment">//  2. 当前线程池状态为 TIDYING 或者 TERMINATED，不需要停止</span></span><br><span class="line">        <span class="comment">//  3. 当前线程池状态为 SHUTDOWN 并且任务队列不为空</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) || runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 判断工作线程的数量是否为 0</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            <span class="comment">// 如果工作线程数量不为 0，就尝试中断正在线程池中的空闲线程</span></span><br><span class="line">            <span class="comment">// ONLY_ONE 说明只尝试中断线程池中第一个线程（不管线程空不空闲）</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将线程状态设为 TIDYING，如果设置不成功说明线程池的状态发生了变化，需要重试</span></span><br><span class="line">            <span class="comment">// 这里线程池状态从 TIDYING 到 TERMINATED 状态转换是原子的</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行 terminated 方法（默认空方法）</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 将线程状态设为 TERMINATED</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 tryTerminate 方法中， 如果满足下面两个条件，就将线程池状态设为 TERMINATED：</p>
<ol>
<li>线程池状态为 SHUTDOWN 并且线程池和任务队列均为空</li>
<li>线程池状态为 STOP 并且线程池为空</li>
</ol>
<p>如果线程池处于 SHUTDOWN 或者 STOP 状态，但是工作线程不为空，那么 tryTerminate 会尝试去中断线程池中的一个线程，这样做主要是为了防止 shutdown 的中断信号丢失（我们在 shutdown 方法处再详细讨论）。下面看下 interruptIdleWorkers 方法，该方法主要中断 <strong>空闲</strong> 线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptIdleWorkers</span><span class="params">(<span class="type">boolean</span> onlyOne)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w: workers) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">            <span class="comment">// 首先看当前线程是否已经中断，如果没有中断，就看线程是否处于空闲状态</span></span><br><span class="line">            <span class="comment">// 如果能获得线程关联的 Worker 锁，说明线程处于空闲状态，可以中断</span></span><br><span class="line">            <span class="comment">// 否则说明线程不能中断</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 onlyOne 为 true，只尝试中断第一个线程</span></span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>通过 shutdown 和 shutdownNow 我们可以关闭线程池，关于两者的区别在前面已经提到了，这里不再赘述。我们首先看下 shutdown 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查当前线程是否有关闭线程池的权限</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 将线程池状态设为 SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断线程，这里最终调用 interruptIdleWorkers(false);</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">// hook 方法，默认为空，让用户在线程池关闭时可以做一些操作</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面我们知道 interruptIdleWorkers 会先检查线程是否是空闲状态，如果发现线程不是空闲状态，才会中断线程。而这时中断线程的主要目的是让在任务队列中阻塞的线程醒过来。考虑下面的情况，如果执行 interruptIdleWorkers 时，线程正在运行，所以没有被中断，但是线程执行完任务之后，任务队列恰好为空，线程就会处于阻塞状态，而此时 shutdown 已经执行完 interruptIdleWorkers 操作了（即线程错过了 shutdown 的中断信号），如果没有额外操作，线程会一直处于阻塞状态。所以为了防止这种情况，在 tryTerminate() 中也增加了 interruptIdleWorkers 操作，主要就是为了弥补 shutdown 中丢失的信号。</p>
<p>最后我们再看下 shutdownNow 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List &lt; Runnable &gt; shutdownNow() &#123;</span><br><span class="line">    List &lt; Runnable &gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查线程是否具有关闭线程池的权限</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 更改线程状态</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 清除任务队列，并将任务返回</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们看下 interruptWorkers 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptWorkers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 不管线程是否空闲都执行中断</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w: workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中我们可以看到在 interruptWorkers 方法中，只要线程开始了，就对线程执行中断，所以 shutdownNow 的中断信号不会丢失。最后我们再看下 drainQueue 方法，该方法主要作用是清空任务队列，并将队列中剩余的任务返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List &lt;Runnable&gt; drainQueue() &#123;</span><br><span class="line">    BlockingQueue &lt;Runnable&gt; q = workQueue;</span><br><span class="line">    ArrayList &lt;Runnable&gt; taskList = <span class="keyword">new</span> <span class="title class_">ArrayList</span> &lt; Runnable &gt; ();</span><br><span class="line">    <span class="comment">// 该方法会将阻塞队列中的所有项添加到 taskList 中</span></span><br><span class="line">    <span class="comment">// 然后清空任务队列，该方法是线程安全的</span></span><br><span class="line">    q.drainTo(taskList);</span><br><span class="line">    <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">    	<span class="comment">// 将 List 转换为 数组，传入的 Runnable[0] 用来说明是转为 Runnable 数组</span></span><br><span class="line">        <span class="keyword">for</span> (Runnable r: q.toArray(<span class="keyword">new</span> <span class="title class_">Runnable</span>[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.remove(r))</span><br><span class="line">                taskList.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> taskList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程池监控"><a href="#线程池监控" class="headerlink" title="线程池监控"></a>线程池监控</h2><blockquote>
<p>本节摘自 <a class="link"   target="_blank" rel="noopener" href="http://ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/" >深入理解Java线程池：ThreadPoolExecutor<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p>
<ul>
<li>getTaskCount：线程池已经执行的和未执行的任务总数；</li>
<li>getCompletedTaskCount：线程池已完成的任务数量，该值小于等于taskCount；</li>
<li>getLargestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize；</li>
<li>getPoolSize：线程池当前的线程数量；</li>
<li>getActiveCount：当前线程池中正在执行任务的线程数量。</li>
</ul>
<p>通过这些方法，可以对线程池进行监控，在ThreadPoolExecutor类中提供了几个空方法，如beforeExecute方法，afterExecute方法和terminated方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自ThreadPoolExecutor来进行扩展。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a class="link"   target="_blank" rel="noopener" href="http://ifeve.com/java-threadpoolexecutor/" >Java线程池架构(一)原理和源码解析<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="http://www.jianshu.com/p/117571856b28" >Java线程池–原理及源码分析<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="http://blog.csdn.net/qq_35101189/article/details/55804778" >http://blog.csdn.net/qq_35101189&#x2F;article&#x2F;details&#x2F;55804778<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="http://zhanjindong.com/2015/03/30/java-concurrent-package-ThreadPoolExecutor" >http://zhanjindong.com/2015/03/30/java-concurrent-package-ThreadPoolExecutor<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="http://ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/" >深入理解Java线程池：ThreadPoolExecutor<i class="fas fa-external-link-alt"></i></a></li>
</ul>

            </div>

            
                <div class="post-copyright-info">
                    
<div class="article-copyright-info-container">
    <ul class="copyright-info-content">
        <li class="post-title">
            <span class="type">本文标题</span>：<span class="content">【Java 并发】详解 ThreadPoolExecutor</span>
        </li>
        <li class="post-author">
            <span class="type">本文作者</span>：<span class="content">Pin Young</span>
        </li>
        <li class="post-time">
            <span class="type">创建时间</span>：<span class="content">2017-04-22 20:39:28</span>
        </li>
        <li class="post-link">
            <span class="type">本文链接</span>：<span class="content">posts/8d0c.html</span>
        </li>
        <li class="post-license">
            <span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span>
        </li>
    </ul>
    <div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/Java/">#Java</a>&nbsp;
                        </li>
                    
                        <li class="tag-item">
                            <a href="/tags/%E5%B9%B6%E5%8F%91/">#并发</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/posts/d298.html"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">【Vue】使用 Vue2 开发一个项目列表展示应用</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/posts/4fd1.html"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">iOS自动打包</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">基本使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">3.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.</span> <span class="nav-text">具体实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Worker"><span class="nav-number">4.1.</span> <span class="nav-text">Worker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">4.2.</span> <span class="nav-text">状态变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1"><span class="nav-number">4.3.</span> <span class="nav-text">添加任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">4.4.</span> <span class="nav-text">关闭线程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%91%E6%8E%A7"><span class="nav-number">5.</span> <span class="nav-text">线程池监控</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="nav-number">6.</span> <span class="nav-text">参考文章</span></a></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2014</span> -
            
            2023
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">Pin Young</a>
            
        </div>
        
            <script async data-pjax
                    src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                
                
                    总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/dstansice">零域Lite 1.3.1</a>
        </div>
        
        
        <script async defer data-website-id="b3b1feba-ef0f-4367-ba34-6a0152b8749b" src="https://analysis.0skyu.cn/umami.js"></script>
         
            <div class="icp-info info-item">
            <div class="theme-info info-item">
                <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12011002021027" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"><img src="https://0skyu.cn/beian.png" style="float:left;"/><p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">津公网安备 12011002021027号</p></a> 
                </div>
                 <div class="theme-info info-item">
               <center> <a target="_blank" rel="nofollow"
                   href="https://beian.miit.gov.cn"
                >
                    津ICP备2021004482号-1
                </a></center>
                </div>
                
            </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>





    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-block.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts pjax">
    
        
<script src="/js/post-helper.js"></script>

        
            
<script src="/js/libs/anime.min.js"></script>

        
        
            
<script src="/js/toc.js"></script>

        
    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
